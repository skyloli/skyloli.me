<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//fonts.loli.net/css?family=Sigmar One:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.35" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/phage.jpg?v=0.0.35"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=0.0.35"><link rel="mask-icon" href="/images/phage.jpg?v=0.0.35" color="#222"><meta name="keywords" content="aphage,blog"><link rel="alternate" href="/atom.xml" title="Hi, aphage" type="application/atom+xml"><meta name="description" content="什么是MQ为什么使用MQ为什么选择RabbitMQ怎么安装RabbitMQRabbitMQ怎么使用RabbitMQ概念RabbitMQ消息事物RabbitMQ消息确认RabbitMQ配置RabbitMQ集群帮助当前版本CentOS 7Erlang 21.xRabbitMQ 3.7.14"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ 入门教程"><meta property="og:url" content="https://aphage.me/rabbitmq/index.html"><meta property="og:site_name" content="Hi, aphage"><meta property="og:description" content="什么是MQ为什么使用MQ为什么选择RabbitMQ怎么安装RabbitMQRabbitMQ怎么使用RabbitMQ概念RabbitMQ消息事物RabbitMQ消息确认RabbitMQ配置RabbitMQ集群帮助当前版本CentOS 7Erlang 21.xRabbitMQ 3.7.14"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5015984-13db639d2c22f2aa.png"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5015984-2f509b7f34c47170.png"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5015984-275ea009bdf806a0.png"><meta property="article:published_time" content="2019-05-01T22:53:25.000Z"><meta property="article:modified_time" content="2020-03-23T02:44:43.791Z"><meta property="article:author" content="aphage"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"0.0.35",sidebar:{position:"right",display:"always",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"2/9/2016 11:30:00",onlineAPI:"",site:{title:"Hi, aphage",subtitle:"",author:"aphage"},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!1,appID:"",appKey:""},favicon:{visibilitychange:!0,narmal:"/images/favicon.ico",hidden:"/images/failure.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/disqusjs@1.0.8/dist/disqus.js"></script><link rel="canonical" href="https://aphage.me/rabbitmq/"><title>RabbitMQ 入门教程 | Hi, aphage</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" class="theme-mai"><div class="container sidebar-position-right page-post-detail"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-后宫"><a href="/friends/" rel="section"><i class="menu-item-icon fa fa-fw fa-mars"></i><br>后宫</a></li><li class="menu-item menu-item-留言板"><a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-pencil"></i><br>留言板</a></li><li class="menu-item search"><form class="search-form"><input name="keyword" type="text" class="search-input" placeholder="站内搜索"> <button type="submit" class="search-submit"><i class="fa fa-search"></i></button></form></li></ul></nav><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate" class="animate"><span>H</span><span>i</span><span>,</span><span> </span><span>a</span><span>p</span><span>h</span><span>a</span><span>g</span><span>e</span></div><div id="guide" class="guide"><span>H</span><span>i</span><span>,</span><span> </span><span>a</span><span>p</span><span>h</span><span>a</span><span>g</span><span>e</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-master-avatar" itemprop="image" src="/images/phage.png" alt="aphage"><h2 class="site-master-description" itemprop="description"><span>写代码是热爱，</span><span>写到世界充满爱！</span></h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">05月</div><div class="post-day">01</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB/" itemprop="url" rel="index"><span itemprop="name">烫烫烫烫</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://aphage.me/rabbitmq/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="aphage"><meta itemprop="description" content=""><meta itemprop="image" content="/images/phage.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, aphage"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">RabbitMQ 入门教程</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-01T22:53:25+00:00">2019-05-01</time> </span><span class="post-comments-count"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/rabbitmq/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="rabbitmq/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><ul><li><a href="#link1">什么是MQ为什么使用MQ</a></li><li><a href="#link2">为什么选择RabbitMQ</a></li><li><a href="#link3">怎么安装RabbitMQ</a></li><li><a href="#link4">RabbitMQ怎么使用</a></li><li><a href="#link5">RabbitMQ概念</a></li><li><a href="#link6">RabbitMQ消息事物</a></li><li><a href="#link7">RabbitMQ消息确认</a></li><li><a href="#link8">RabbitMQ配置</a></li><li><a href="#link9">RabbitMQ集群</a></li><li><a href="#link10">帮助</a></li></ul><h1 id="当前版本"><a href="#当前版本" class="headerlink" title="当前版本"></a>当前版本</h1><blockquote><ul><li>CentOS 7</li><li>Erlang 21.x</li><li>RabbitMQ 3.7.14</li></ul></blockquote><a id="more"></a><div id="link1"></div><h2 id="什么是MQ-为什么要使用MQ"><a href="#什么是MQ-为什么要使用MQ" class="headerlink" title="什么是MQ,为什么要使用MQ"></a>什么是MQ,为什么要使用MQ</h2><p>哈，MQ你都不知道，你还来这里，茨~ 快去百度啦</p><p>为什么使用MQ</p><p>话说，你都不知道为什么使用MQ，那你还来这里干嘛？</p><hr><div id="link2"></div><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>现在的市面上有很多MQ可以选择，比如ActiveMQ、ZeroMQ、Appche Qpid，那问题来了为什么要选择RabbitMQ？</p><blockquote><ol><li>除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；</li><li>可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；</li><li>高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开&gt; 发4. 的语言，天生自带高并发光环，和高可用特性；</li><li>集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；</li><li>社区活跃度高，根据网上资料来看，RabbitMQ也是首选；</li></ol></blockquote><hr><h3 id="MQ-对比"><a href="#MQ-对比" class="headerlink" title="MQ 对比"></a>MQ 对比</h3><p>我们先来看一些数据</p><p>阿里官网对比</p><table><thead><tr><th>功能</th><th>消息队列 RocketMQ</th><th>Apache RocketMQ（开源）</th><th>消息队列 Kafka</th><th>Apache Kafka（开源）</th><th>RabbitMQ（开源）</th></tr></thead><tbody><tr><td>安全防护</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>主子账号支持</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>可靠性</td><td>同步刷盘 - 同步双写 - 超3份数据副本 - 99.99999999%</td><td>- 同步刷盘 - 异步刷盘 -</td><td>同步刷盘 - 同步双写 - 超3份数据副本 - 99.99999999%</td><td>异步刷盘，丢数据概率高</td><td>同步刷盘</td></tr><tr><td>可用性</td><td>- 非常好，99.95% - Always Writable</td><td>好</td><td>- 非常好，99.95% - Always Writable</td><td>好</td><td>好</td></tr><tr><td>横向扩展能力</td><td>- 支持平滑扩展 - 支持百万级 QPS</td><td>支持</td><td>- 支持平滑扩展 - 支持百万级 QPS</td><td>支持</td><td>- 集群扩容依赖前端 - LVS 负载均衡调度</td></tr><tr><td>Low Latency</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消费模型</td><td>Push / Pull</td><td>Push / Pull</td><td>Push / Pull</td><td>Pull</td><td>Push / Pull</td></tr><tr><td>定时消息</td><td>支持（可精确到秒级）</td><td>支持（只支持18个固定 Level）</td><td>暂不支持</td><td>不支持</td><td>支持</td></tr><tr><td>事务消息</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>顺序消息</td><td>支持</td><td>支持</td><td>暂不支持</td><td>支持</td><td>不支持</td></tr><tr><td>全链路消息轨迹</td><td>支持</td><td>不支持</td><td>暂不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息堆积能力</td><td>百亿级别 不影响性能</td><td>百亿级别 影响性能</td><td>百亿级别 不影响性能</td><td>影响性能</td><td>影响性能</td></tr><tr><td>消息堆积查询</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息回溯</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息重试</td><td>支持</td><td>支持</td><td>暂不支持</td><td>不支持</td><td>支持</td></tr><tr><td>死信队列</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>性能（常规）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>非常好 百万级 QPS</td><td>一般 万级 QPS</td></tr><tr><td>性能（万级 Topic 场景）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>低</td><td>低</td></tr><tr><td>性能（海量消息堆积场景）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>低</td><td>低</td></tr></tbody></table><hr><table><thead><tr><th>xxxxxxxxxxxxxxxxxx</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMq</th><th>ZeroMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>关注度</td><td>高</td><td>高</td><td>中</td><td>中</td><td>高</td></tr><tr><td>成熟度</td><td>成熟</td><td>成熟</td><td>比较成熟</td><td>不成熟</td><td>成熟</td></tr><tr><td>所属社区/公司</td><td>Apache</td><td>Mozilla Public License</td><td>Alibaba Apache</td><td></td><td></td></tr><tr><td>社区活跃度</td><td>高</td><td>高</td><td>中</td><td>低</td><td>高</td></tr><tr><td>文档</td><td>多</td><td>多</td><td>中</td><td>中</td><td>多</td></tr><tr><td>特点</td><td>功能齐全，被大量开源项目使用</td><td>由于Erlang 语言的并发能力，性能很好</td><td>各个环节分布式扩展设计，主从 HA；支持上万个队列；多种消费模式；性能很好</td><td>低延时，高性能，最高 43万条消息每秒</td><td></td></tr><tr><td>授权方式</td><td>开源</td><td>开源</td><td>开源</td><td>开源</td><td>开源</td></tr><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>C</td><td></td></tr><tr><td>支持的协议</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>AMQP 自己定义的一套(社区提供JMS–不成熟)</td><td>TCP、UDP</td><td></td><td></td></tr><tr><td>客户端支持语言</td><td>Java、C、C++、Python、PHP、Perl、.net 等</td><td>Java、C、C++、Python、PHP、Perl、.net 等</td><td>Java C++（不成熟）</td><td>python java、 php、.net 等</td><td></td></tr><tr><td>持久化</td><td>内存、文件、数据库</td><td>内存、文件</td><td>磁盘文件</td><td>在消息发送端保存</td><td></td></tr><tr><td>事务</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>集群</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>负载均衡</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>管理界面</td><td>一般</td><td>好</td><td>无社区有 web console 实现</td><td>无</td><td></td></tr><tr><td>部署方式</td><td>独立、嵌入</td><td>独立</td><td>独立</td><td>独立</td><td></td></tr><tr><td>顺序</td><td>无法保证严格的顺序</td><td></td><td>保证严格的消费顺序</td><td></td><td></td></tr><tr><td>优点</td><td>成熟的产品，已经在很多公司得到应用（非大规模场景）。有较多的文档。各种协议支持较好，有多重语言的成熟的客户端；</td><td>由于erlang语言的特性，mq 性能较好；管理界面较丰富，在互联网公司也有较大规模的应用；支持amqp系诶，有多中语言且支持 amqp 的客户端可用</td><td>模型简单，接口易用（JMS 的接口很多场合并不太实用）。在阿里大规模应用。目前支付宝中的余额宝等新兴产品均使用rocketmq。集群规模大概在50 台左右，单日处理消息上百亿；性能非常好，可以大量堆积消息在broker 中；支持多种消费，包括集群消费、广播消费等。开发度较活跃，版本更新很快。</td><td></td><td></td></tr><tr><td>缺点</td><td>根据其他用户反馈，会出莫名其妙的问题，切会丢失消息。 其重心放到activemq6.0 产品—apollo 上去了，目前社区不活跃，且对 5.x 维护较少;Activemq 不适合用于上千个队列的应用场景</td><td>erlang语言难度较大。集群不支持动态扩展。</td><td>没有在 mq 核心中去实现JMS 等接口</td><td></td><td></td></tr></tbody></table><hr><h3 id="知道了吗？为什么选择RabbitMQ！！！！！！"><a href="#知道了吗？为什么选择RabbitMQ！！！！！！" class="headerlink" title="知道了吗？为什么选择RabbitMQ！！！！！！"></a>知道了吗？为什么选择RabbitMQ！！！！！！</h3><p><strong>(小声的说：其实！！！我也没用过MQ，各大厂商都实现了一套，所以我准备选择一个先了解一下)</strong></p><p><strong>为什么选择RabbitMQ呢？</strong></p><blockquote><ul><li><strong>因为我也是第一次接触MQ，选择的原因嘛，是RabbitMQ时间比较久了，资料比较多，刚入手肯定选择资料比较多的最好</strong></li><li><strong>还有Rabbit是兔子的意思嘛，一想到兔子，很可爱啊！！！</strong></li></ul></blockquote><hr><div id="link3"></div><h2 id="怎么安装RabbitMQ"><a href="#怎么安装RabbitMQ" class="headerlink" title="怎么安装RabbitMQ"></a>怎么安装RabbitMQ</h2><p>打开<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">官网</a>看了吗？</p><p>Download + Installation</p><p>哈！！！没看到，你网速太差了吧，那你等一下吧！</p><p>还是没看到！哦，那你点击一下<a href="https://www.rabbitmq.com/#getstarted" target="_blank" rel="noopener">我</a>吧！</p><p>啊<del>~ ~别点了</del>啊<del>~</del>～(￣▽￣～)</p><blockquote><p>我怀疑你在开车，但是我没有证据</p></blockquote><hr><p>OK，现在到<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">这里</a>了</p><p>我的是CentOS7 所以我点击<a href="https://www.rabbitmq.com/install-rpm.html" target="_blank" rel="noopener">这个</a></p><p>其他的系统自己研究了~ RabbitMQ 是Erlange开发了，所以要先安装Erlang，版本有要求哦</p><p>进来后看到<a href="https://www.rabbitmq.com/install-rpm.html#install-erlang" target="_blank" rel="noopener">Install Erlang</a></p><p>下面有一个<a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">a package</a> 的一个链接，点击跳转到了Github</p><p>往下面拉，这里我选择最新版本的Erlang 源，Erlang 21.x，当前版本的RabbitMQ3.7.14 也要求Erlang &gt;= 19.3</p><p>在往下拉，可以看到指定版本的Erlang 安装源</p><p>源安装好像有两种 Package Cloud、Bintray Yum Repositories</p><p>我选择第一种的，但是我没有操作这个<br>Package Cloud supports a variety of options for RPM package installation: from Yum configuration to shell scripts to Chef and Puppet.</p><p>See Package Cloud repository installation page for details.</p><p>也安装好了~嘛 再往下拉就能看到Bintray Yum Repositories，也可以用这个源安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># In &#x2F;etc&#x2F;yum.repos.d&#x2F;rabbitmq_erlang.repo</span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name&#x3D;rabbitmq_erlang</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;el&#x2F;7&#x2F;$basearch</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;gpgkey</span><br><span class="line">sslverify&#x3D;1</span><br><span class="line">sslcacert&#x3D;&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">metadata_expire&#x3D;300</span><br><span class="line">  </span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name&#x3D;rabbitmq_erlang-source</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;el&#x2F;7&#x2F;SRPMS</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;gpgkey</span><br><span class="line">sslverify&#x3D;1</span><br><span class="line">sslcacert&#x3D;&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">metadata_expire&#x3D;300</span><br></pre></td></tr></table></figure><p>配置好后就安装了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y erlang</span><br></pre></td></tr></table></figure><p>安装好Erlang后开始安装RabbitMQ了</p><p>我们回到<a href="https://www.rabbitmq.com/install-rpm.html#bintray" target="_blank" rel="noopener">这里，快点击我啊~</a></p><p>这里使用Bintray 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;signing-keys&#x2F;releases&#x2F;download&#x2F;2.0&#x2F;rabbitmq-release-signing-key.asc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># In &#x2F;etc&#x2F;yum.repos.d&#x2F;rabbitmq.repo</span><br><span class="line">[bintray-rabbitmq-server]</span><br><span class="line">name&#x3D;bintray-rabbitmq-rpm</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;dl.bintray.com&#x2F;rabbitmq&#x2F;rpm&#x2F;rabbitmq-server&#x2F;v3.7.x&#x2F;el&#x2F;7&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure><p>写完配置后，安装，没有指定版本号默认安装最新版,我这里的是 <strong>3.7.14</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y rabbitmq-server.noarch</span><br></pre></td></tr></table></figure><h3 id="启动服务RabbitMQ器"><a href="#启动服务RabbitMQ器" class="headerlink" title="启动服务RabbitMQ器"></a>启动服务RabbitMQ器</h3><p>设置开机启动，默认是不会开机启动，大家自己选择</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p>启动RabbitMQ，Centos7 已经使用systemctl 替代 service 命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重新启动</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p>也可是使用RabbitMQ 提供的命令查看状态，更多关于rabbitmqctl 命令请<a href="https://www.rabbitmq.com/rabbitmqctl.8.html" target="_blank" rel="noopener">点击这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure><p>我选择开启Web 管理插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line">  </span><br><span class="line">rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 注意：插件的启用和关闭都不会影响当前运行rabbitmq节点。必须重新启动之后才会影响。</span></span><br></pre></td></tr></table></figure><p>打开 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p>输入guest guest</p><p>默认的用户guest只能在安装RabbitMQ的机器上登录，在其他机器登录需要新增用户！,当然利用配置文件也可以实现让guest用户在其他机器登陆！！</p><p>这里我选择新建用户</p><p>添加用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user username password</span><br></pre></td></tr></table></figure><p>设置用户标签（administrator），用户标签的用处主要是管理插件使用的，设置administrator 是让这个用户可以访问 Web端管理程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags username administrator</span><br></pre></td></tr></table></figure><p>设置 虚拟主机权限，RabbitMQ 是使用虚拟主机隔离的，每一个虚拟主机都用自己的交换机和队列，每个虚拟主机互相隔离</p><p>/ 是默认的虚拟主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions username -p / <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p>设置完后就可以远程使用这个用户登录Web 管理端了</p><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="User-用户"><a href="#User-用户" class="headerlink" title="User | 用户"></a><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management" target="_blank" rel="noopener">User | 用户</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户列表</span></span><br><span class="line">rabbitctl list_users</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user username password</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">rabbitmqctl delete_user username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">rabbitmqctl change_password username password</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清除密码</span></span><br><span class="line">rabbitmqcaltl clear_password username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置标签</span></span><br><span class="line">rabbitmqctl set_user_tags username administrator</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清空标签</span></span><br><span class="line">rabbitmqctl set_user_tags username</span><br></pre></td></tr></table></figure><h4 id="Access-Control-访问控制"><a href="#Access-Control-访问控制" class="headerlink" title="Access Control | 访问控制"></a><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#Access_Control" target="_blank" rel="noopener">Access Control | 访问控制</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虚拟主机列表</span></span><br><span class="line">rabbitmqctl list_vhosts</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加虚拟主机</span></span><br><span class="line">rabbitmqctl add_vhost vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除虚拟主机</span></span><br><span class="line">rabbitmqctl delete_vhost vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置权限用户</span></span><br><span class="line">rabbitmqctl set_permissions -p vhost username <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#清空用户权限</span></span><br><span class="line">rabbitmqctl clear_permissions -p vhost username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 虚拟主机下的用户</span></span><br><span class="line">rabbitmqctl list_permissions -p vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 用户下的虚拟主机</span></span><br><span class="line">rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure><hr><div id="link4"></div><h2 id="RabbitMQ怎么使用"><a href="#RabbitMQ怎么使用" class="headerlink" title="RabbitMQ怎么使用"></a>RabbitMQ怎么使用</h2><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>我使用的是Java 客户端 其他语言自己查阅官方文档</p><p>根据<a href="https://www.rabbitmq.com/java-client.html" target="_blank" rel="noopener">官方文档</a></p><p>我们要引入客户端</p><p>如果使用Maven</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>如果使用Gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &#39;com.rabbitmq:amqp-client:5.7.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来到<a href="https://www.rabbitmq.com/api-guide.html" target="_blank" rel="noopener">api文档</a>，看看Java怎么使用RabbitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">// "guest"/"guest" by default, limited to localhost connections</span></span><br><span class="line">factory.setUsername(userName);</span><br><span class="line">factory.setPassword(password);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(hostName);</span><br><span class="line">factory.setPort(portNumber);</span><br><span class="line">  </span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><table><thead><tr><th>Property</th><th>Default Value</th></tr></thead><tbody><tr><td>Username</td><td>“guest”</td></tr><tr><td>Password</td><td>“guest”</td></tr><tr><td>Virtual host</td><td>“/“</td></tr><tr><td>Hostname</td><td>“localhost”</td></tr><tr><td>port</td><td>5672 for regular connections, 5671 for connections that use TLS</td></tr></tbody></table><p>还可以使用URLs方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@hostName:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>我使用URLs方式，如果你要连接到默认的虚拟主机/，需要将/转义也就是%2F，其他不用</p><p>这里我直接写测试类里面了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aphage</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String uri = <span class="string">"amqp://%s:%s@%s:%d/%s"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"192.168.92.128"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = AMQP.PROTOCOL.PORT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME= <span class="string">"Aqua"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"Aqua"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VHOST = <span class="string">"%2F"</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory factory=<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(String.format(uri,USERNAME,PASSWORD,HOST,PORT,VHOST));</span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=conn)conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明交换机和队列并绑定"><a href="#声明交换机和队列并绑定" class="headerlink" title="声明交换机和队列并绑定"></a>声明交换机和队列并绑定</h3><p>声明交换机和队列的时候分为两种情况</p><ol><li>声明的交换机和队列不存在，就会创建</li><li>如果存在，就不会</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><ol><li>一种持久的，非自动交换的“直接”类型</li><li>具有生成名称的非持久，独占，自动删除队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><ol><li>一种持久的，非自动交换的“直接”类型</li><li>具有已知名称的持久，非独占，非自动删除队列</li></ol><h3 id="声明交换机"><a href="#声明交换机" class="headerlink" title="声明交换机"></a>声明交换机</h3><p>根据上面的代码，我们先来声明一些交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. 交换机名称</span></span><br><span class="line"><span class="comment">    * 2. 交换机类型</span></span><br><span class="line"><span class="comment">    * 3. 是否永久存在，false 为临时重启消失</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//直接类型</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"direct-forever"</span>, BuiltinExchangeType.DIRECT,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"direct-temporary"</span>, BuiltinExchangeType.DIRECT,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//广播类型 routing key 忽略无效</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"fanout-forever"</span>, BuiltinExchangeType.FANOUT,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"fanout-temporary"</span>, BuiltinExchangeType.FANOUT,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//广播类型 routing key 模糊匹配</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"topic-forever"</span>, BuiltinExchangeType.TOPIC,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"topic-temporary"</span>, BuiltinExchangeType.TOPIC,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//使用键值对匹配</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"headers-forever"</span>, BuiltinExchangeType.HEADERS,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"headers-temporary"</span>, BuiltinExchangeType.HEADERS,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>交换机类型分为四种 direct、fanout、topic、header（这个性能最差）</li><li>channel 官方建议不要多线程共享，最好一个线程使用一个channel</li></ul></blockquote><p>然后登陆Web 管理界面查看</p><p><a href="http://192.168.92.128:15672/#/exchanges" target="_blank" rel="noopener">http://192.168.92.128:15672/#/exchanges</a></p><p>发现已经有我们声明的交换机了</p><p>其中还有一些默认的交换机</p><p>我们也可以看到交换机是在虚拟主机中的、每个虚拟主机互相隔离</p><p>我们也发现在Features列，永久的交换机是带有D标签的</p><hr><p>接下来我们来声明队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queue - 队列的名称</span></span><br><span class="line"><span class="comment">    * durable - 如果我们声明一个持久队列，则为true（队列将在服务器重启后继续存在）</span></span><br><span class="line"><span class="comment">    * exclusive - 如果我们声明一个独占队列（仅限于此连接），则为true</span></span><br><span class="line"><span class="comment">    * autoDelete - 如果我们声明一个自动删除队列，则为true（服务器将在不再使用时将其删除）,消费者断开连接时是否删除队列</span></span><br><span class="line"><span class="comment">    * arguments - 队列的其他属性（构造参数）</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    channel.queueDeclare(<span class="string">"Aqua-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"fanout1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"fanout2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic3-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"headers1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"headers2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//主动声明一个服务器命名的独占，自动删除，非持久队列。</span></span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用System.in.read 进行阻塞</p><p>打开 <a href="http://192.168.92.128:15672/#/queues" target="_blank" rel="noopener">http://192.168.92.128:15672/#/queues</a></p><p>我们可以看到我们的队列已经出来了，也有一些临时队列</p><p>声明队列也就两个api 函数</p><p>当我们点击结束进程的时候，断开连接了，临时队列就会自动删除</p><p>队列也有了，接下来就是和交换机绑定了，不然发送的数据没办法进入队列</p><p>因为exchange 是负责数据转发的，而队列（queue）只是保存数据的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//队列绑定交换机，一个队列可绑定多个交换机</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queue - 队列的名称</span></span><br><span class="line"><span class="comment">    * exchange - 交易所的名称</span></span><br><span class="line"><span class="comment">    * routingKey - 用于绑定的路由密钥</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到直接交换机</span></span><br><span class="line">    channel.queueBind(<span class="string">"Aqua-forever"</span>,<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播(fanout类型，对Routing Key无效)</span></span><br><span class="line">    channel.queueBind(<span class="string">"fanout1-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"fanout2-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播 routing key 模糊匹配</span></span><br><span class="line">    channel.queueBind(<span class="string">"topic1-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.#"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"topic2-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.mea.*"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"topic3-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.suki.*"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播(fanout类型，对Routing Key无效)</span></span><br><span class="line">    channel.queueBind(<span class="string">"fanout1-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"fanout2-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>);</span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"x-match"</span>, <span class="string">"any"</span>);<span class="comment">//这代表消息携带的Hash是需要全部匹配键值(all)，还是仅匹配一个键值(any)就可以了</span></span><br><span class="line">    map.put(<span class="string">"xxx"</span>,<span class="string">"111"</span>);</span><br><span class="line">    map.put(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"headers1-forever"</span>,<span class="string">"headers-forever"</span>,<span class="string">""</span>,map);</span><br><span class="line">    map.put(<span class="string">"x-match"</span>, <span class="string">"all"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"headers2-forever"</span>,<span class="string">"headers-forever"</span>,<span class="string">""</span>,map);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来发送消息（生产消息）到服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">    <span class="comment">//发送消息(生产消息)</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//routing key 直接忽略</span></span><br><span class="line">    channel.basicPublish(<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    topic路由器的关键在于定义路由键，定义routingKey名称不能超过255字节，使用“.”作为分隔符，例如：com.mq.rabbit.error。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    消费消息的时候routingKey可以使用下面字符匹配消息：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    "*"匹配一个分段(用“.”分割)的内容；</span></span><br><span class="line"><span class="comment">    "#"匹配0和多个字符；</span></span><br><span class="line"><span class="comment">    例如发布了一个“com.mq.rabbit.error”的消息：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    能匹配上的路由键：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    cn.mq.rabbit.*</span></span><br><span class="line"><span class="comment">    cn.mq.rabbit.#</span></span><br><span class="line"><span class="comment">    #.error</span></span><br><span class="line"><span class="comment">    cn.mq.#</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    不能匹配上的路由键：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    cn.mq.*</span></span><br><span class="line"><span class="comment">    *.error</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    所以如果想要订阅所有消息，可以使用“#”匹配。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.hello"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.mea.suki"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.suki.me"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"xxx"</span>,<span class="string">"111"</span>);</span><br><span class="line">    channel.basicPublish(<span class="string">"headers-forever"</span>,<span class="string">""</span>,<span class="keyword">new</span> AMQP.BasicProperties().builder().headers(map).build(),getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        throws IOException;</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        throws IOException;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    他们共有的参数分别是：</span></span><br><span class="line"><span class="comment">    exchange：交换机名称</span></span><br><span class="line"><span class="comment">    routingKey：路由键</span></span><br><span class="line"><span class="comment">    props：消息属性字段，比如消息头部信息等等</span></span><br><span class="line"><span class="comment">    body：消息主体部分</span></span><br><span class="line"><span class="comment">    除此之外，还有mandatory和immediate这两个参数，鉴于RabbitMQ3.0不再支持immediate标志，因此我们重点讨论mandatory标志</span></span><br><span class="line"><span class="comment">    mandatory的作用：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    当mandatory标志位设置为true时，如果exchange根据自身类型和消息routingKey无法找到一个合适的queue存储消息，那么broker会调用basic.return方法将消息返还给生产者;</span></span><br><span class="line"><span class="comment">    当mandatory设置为false时，出现上述情况broker会直接将消息丢弃;通俗的讲，mandatory标志告诉broker代理服务器至少将消息route到一个队列中，否则就将消息return给发送者;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Return(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里我们尝试发送无法路由的数据</span></span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-tietie"</span>,<span class="keyword">true</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    channel.addReturnListener((i, s, s1, s2, basicProperties, bytes) -&gt;</span><br><span class="line">            System.out.println(String.format(<span class="string">"replyCode=%d replyText=%s exchange=%s routingKey=%s body=%s"</span>,i,s,s1,s2,<span class="keyword">new</span> String(bytes,<span class="string">"UTF-8"</span>)))</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">" : Hello Aqua!!!!!!!!!!!!! prpr!!!!!!!!!!!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后可以看到控制台输出无法路由的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replyCode&#x3D;312 replyText&#x3D;NO_ROUTE exchange&#x3D;direct-forever routingKey&#x3D;Aqua-tietie body&#x3D;2019-05-14 17:00:53 : Hello Aqua!!!!!!!!!!!!! prpr!!!!!!!!!!!!!</span><br></pre></td></tr></table></figure><p>打开 <a href="http://192.168.92.128:15672/#/queues" target="_blank" rel="noopener">http://192.168.92.128:15672/#/queues</a> 可以看到数据已经到达队列中了</p><hr><p>下面我们可以从消息队列中取数据了，取数据比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.队列名称</span></span><br><span class="line"><span class="comment">        * 2. auto ack 自动确认</span></span><br><span class="line"><span class="comment">        * 3. consumerTag 取消回调的时候用的</span></span><br><span class="line"><span class="comment">        * 4. 接受消息回调</span></span><br><span class="line"><span class="comment">        * 5. 回调被取消的回调 例如队列被删除，或者在集群方案中，队列所在的节点失败</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        channel.basicConsume(<span class="string">"Aqua-forever"</span>,<span class="keyword">false</span>,<span class="string">"Aqua-listened-1"</span>,(s, delivery) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"tag: %s exchange: %s routing key: %s"</span>,s,delivery.getEnvelope().getExchange(),delivery.getEnvelope().getRoutingKey()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"msg: %s"</span>,<span class="keyword">new</span> String(delivery.getBody(),<span class="string">"UTF-8"</span>)));</span><br><span class="line">  </span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125;,s -&gt; System.out.println(<span class="string">"监听被取消: "</span>+ s));</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//这里我们没有进行确认，当与服务器断开连接，数据将会重新放回队列</span></span><br><span class="line">        <span class="comment">//让其他消费者进行消费</span></span><br><span class="line">        channel.basicConsume(<span class="string">"fanout1-forever"</span>,<span class="keyword">false</span>,<span class="string">"Aqua-listened-2"</span>,(s, delivery) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"tag: %s exchange: %s routing key: %s"</span>,s,delivery.getEnvelope().getExchange(),delivery.getEnvelope().getRoutingKey()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"msg: %s"</span>,<span class="keyword">new</span> String(delivery.getBody(),<span class="string">"UTF-8"</span>)));</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span></span><br><span class="line">        &#125;,s -&gt; System.out.println(<span class="string">"监听被取消: "</span>+ s));</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//也可是使用DefaultConsumer 官方文档用的就是这个</span></span><br><span class="line"><span class="comment">//        channel.basicConsume("Aqua-forever",false,"Aqua-listened",new DefaultConsumer(channel)&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                channel.basicAck(envelope.getDeliveryTag(),false);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">  </span><br><span class="line">        channel.addShutdownListener(e -&gt;</span><br><span class="line">            System.out.println(String.format(<span class="string">"连接关闭 %s %b"</span>,e.getMessage(),e.isHardError()))</span><br><span class="line">        );</span><br><span class="line">  </span><br><span class="line">        System.in.read();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果autoAck设置为false，需要调用basicAck 进行确认，未确认的将放到未确认队列，如果此时客户端断开连接，将重新放回原队列</p><p>如果autoAck设置为true，则服务器发送消息后，将消息从客户端移除</p><p><strong>需要查阅API <a href="#帮助">请点击</a></strong></p><hr><div id="link5"></div><h2 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>看图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png" alt="我是图片"></p><ol><li>Message</li></ol><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><ol start="2"><li>Publisher</li></ol><p>消息的生产者，就是发送消息的，也是一个向交换器发布消息的客户端应用程序。</p><ol start="3"><li>Exchange</li></ol><p>交换器，就是转发消息的，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><ol start="4"><li>Binding</li></ol><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><p>队列绑定交换机，一个队列可以绑定多个交换机，一个交换机也可以对应多个队列，多对多关系</p><ol start="5"><li>Queue</li></ol><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ol start="6"><li>Connection</li></ol><p>网络连接，比如一个TCP连接。</p><ol start="7"><li>Channel</li></ol><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p>其实是一个Channel对应一条TCP连接，还有官方建议不要多线程共享Channel，最好是一个线程对应一个Channel</p><ol start="8"><li>Consumer</li></ol><p>接收消息的，消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ol start="9"><li>Virtual Host</li></ol><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的<br>RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ol start="10"><li>Broker</li></ol><p>表示消息队列服务器实体。</p><h3 id="AMQP中的消息路由"><a href="#AMQP中的消息路由" class="headerlink" title="AMQP中的消息路由"></a>AMQP中的消息路由</h3><p><img src="https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png" alt="我是图片"></p><p>生产者发送消息到交换机，交换机根据交换机类型和参数、绑定的队列，转发到对应的队列</p><p>消费者去队列取出数据</p><h3 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h3><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路<br>由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型</p><ol><li>direct</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-13db639d2c22f2aa.png" alt="我是图片"></p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><ol start="2"><li>fanout</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-2f509b7f34c47170.png" alt="我是图片"></p><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><ol start="3"><li>topic</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-275ea009bdf806a0.png" alt="我是图片"></p><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配不多不少一个单词。</p><blockquote><ul><li>basicPublish​(String exchange, String routingKey, boolean mandatory, boolean immediate, AMQP.BasicProperties props, byte[] body)</li><li>basicPublish​(String exchange, String routingKey, boolean mandatory, AMQP.BasicProperties props, byte[] body)</li><li>basicPublish​(String exchange, String routingKey, AMQP.BasicProperties props, byte[] body)</li><li>可以根据 mandatory 进行无法路由的消息进行处理</li><li>mandatory = false 无法路由的消息直接丢弃</li><li>mandatory = true 无法路由的消息通过 Return 回调函数 通知</li><li>immediate RabbitMQ 3.0 不再支持此标记</li></ul></blockquote><hr><div id="link6"></div><h2 id="RabbitMQ消息事务"><a href="#RabbitMQ消息事务" class="headerlink" title="RabbitMQ消息事务"></a>RabbitMQ消息事务</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>消息事物保证消息一定到达RabbitMQ服务器</p><p>只有三个Api</p><p>channel.txSelect() 声明启动事务模式；</p><p>channel.txComment() 提交事务；</p><p>channel.txRollback() 回滚事务；</p><p>虽然当你调用publish 发送到服务器的时候，服务器收到并不会把他立刻放到队列，只有事务提交才会进入队列</p><p>事务性能很低，事务api 比较简单没有什么好描述的了</p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>扩展知识<br>我们知道，消费者可以使用消息自动或手动发送来确认消费消息，那如果我们在消费者模式中使用事务（当然如果使用了手动确认消息，完全用不到事务的），会发生什么呢？</p><p>消费者模式使用事务</p><p>假设消费者模式中使用了事务，并且在消息确认之后进行了事务回滚，那么RabbitMQ会产生什么样的变化？</p><p>结果分为两种情况：</p><ol><li><p>autoAck=false手动应对的时候是支持事务的，也就是说即使你已经手动确认了消息已经收到了，但在确认消息会等事务的返回解决之后，在做决定是确认消息还是重新放回队列，如果你手动确认现在之后，又回滚了事务，那么已事务回滚为主，此条消息会重新放回队列；</p></li><li><p>autoAck=true如果自定确认为true的情况是不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了；</p></li></ol><hr><div id="link7"></div><h2 id="RabbitMQ消息确认"><a href="#RabbitMQ消息确认" class="headerlink" title="RabbitMQ消息确认"></a>RabbitMQ消息确认</h2><p>Confirm发送方确认模式使用和事务类似，也是通过设置Channel进行发送方确认的。</p><p>效率比事务要快</p><p>Confirm的三种实现方式：</p><ol><li><p>channel.waitForConfirms()普通发送方确认模式；</p></li><li><p>channel.waitForConfirmsOrDie()批量确认模式；</p></li><li><p>channel.addConfirmListener()异步监听发送方确认模式；</p></li></ol><p>使用 channel.confirmSelect() 开启消息确认回调</p><h3 id="普通Confirm模式"><a href="#普通Confirm模式" class="headerlink" title="普通Confirm模式"></a>普通Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test77</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    <span class="keyword">if</span>(channel.waitForConfirms())</span><br><span class="line">        System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"发送失败"</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量Confirm模式"><a href="#批量Confirm模式" class="headerlink" title="批量Confirm模式"></a>批量Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test777</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.waitForConfirmsOrDie();</span><br><span class="line">    System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步Confirm模式"><a href="#异步Confirm模式" class="headerlink" title="异步Confirm模式"></a>异步Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以看出，代码是异步执行的，消息确认有可能是批量确认的，是否批量确认在于返回的multiple的参数，</span></span><br><span class="line"><span class="comment">        此参数为bool值，如果true表示批量执行了deliveryTag这个值以前的所有消息，如果为false的话表示单条确认。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    channel.addConfirmListener((l, b) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"已经确认 "</span>+ l + <span class="string">" "</span> + b);</span><br><span class="line">    &#125;,(l, b) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"未确认 "</span> + l + <span class="string">" "</span> + b);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>性能比较 普通模式 &lt; 批量模式 &lt; 异步模式</li></ul></blockquote><hr><div id="link8"></div><h2 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h2><p>文件需要自己创建</p><p>rabbitmq.conf和rabbitmq-env.conf的位置<br>这些文件的位置是特定于分发的。默认情况下，它们不是创建的，但希望位于每个平台的以下位置：</p><p>通用UNIX：<code>$RABBITMQ_HOME/etc/rabbitmq/</code><br>Debian：<code>/etc/rabbitmq/</code><br>RPM：<code>/etc/rabbitmq/</code><br>Mac OS（Homebrew）：<code>${install_prefix}/etc/rabbitmq/</code>，Homebrew地窖前缀通常是<code>/usr/local</code><br>Windows：<code>％APPDATA％\RabbitMQ\</code><br>如果rabbitmq-env.conf不存在，则可以在由RABBITMQ_CONF_ENV_FILE变量指定的位置手动创建。在Windows系统上，它名为rabbitmq-env.bat。</p><p>如果rabbitmq.conf不存在，可以手动创建。如果更改位置，请设置RABBITMQ_CONFIG_FILE环境变量。RabbitMQ自动将.conf扩展名附加到此变量的值。</p><p>更改后重新启动服务器。添加或删除配置文件后，Windows服务用户需要重新安装该服务</p><p><a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">官方文档</a></p><hr><div id="link9"></div><h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><h3 id="Rabbitmq集群高可用"><a href="#Rabbitmq集群高可用" class="headerlink" title="Rabbitmq集群高可用"></a>Rabbitmq集群高可用</h3><p>RabbitMQ是用erlang开发的，集群非常方便，因为erlang天生就是一门分布式语言,但其本身并不支持负载均衡。</p><p>Rabbit模式大概分为以下三种：单一模式、普通模式、镜像模式<br>集群最少需要一个磁盘节点</p><h4 id="单一模式：最简单的情况，非集群模式。"><a href="#单一模式：最简单的情况，非集群模式。" class="headerlink" title="单一模式：最简单的情况，非集群模式。"></a>单一模式：最简单的情况，非集群模式。</h4><p>没什么好说的。</p><h4 id="普通模式：默认的集群模式。"><a href="#普通模式：默认的集群模式。" class="headerlink" title="普通模式：默认的集群模式。"></a>普通模式：默认的集群模式。</h4><p>对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构。</p><p>当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。</p><p>所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连A或B，出口总在A，会产生瓶颈。</p><p>该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。</p><p>如果做了消息持久化，那么得等A节点恢复，然后才可被消费；如果没有持久化的话，然后就没有然后了……</p><h4 id="镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。"><a href="#镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。" class="headerlink" title="镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。"></a>镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。</h4><p>该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。</p><p>该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。</p><p>所以在对可靠性要求较高的场合中适用(后面会详细介绍这种模式，目前我们搭建的环境属于该模式)</p><p>启动磁盘节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>查看集群状态</p><p>rabbit1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>加入集群，只要加入其中一个节点就可以了</p><p>rabbit2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>rabbit3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>退出集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on rabbit3</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># =&gt; Stopping node rabbit@rabbit3 ...done.</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># =&gt; Resetting node rabbit@rabbit3 ...done.</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment"># =&gt; Starting node rabbit@rabbit3 ...done.</span></span><br></pre></td></tr></table></figure><p>使用Rabbit镜像功能，需要基于rabbitmq策略来实现，政策是用来控制和修改群集范围的某个vhost队列行为和Exchange行为</p><p>在cluster中任意节点启用策略，策略会自动同步到集群节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p hrsystem ha-allqueue<span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all"&#125;'</span></span><br></pre></td></tr></table></figure><p>这行命令在vhost名称为hrsystem创建了一个策略，策略名称为ha-allqueue,策略模式为 all 即复制到所有节点，包含新增节点，<br>策略正则表达式为 “^” 表示所有匹配所有队列名称。<br>例如rabbitmqctl set_policy -p hrsystem ha-allqueue “^message” ‘{“ha-mode”:”all”}’<br>注意：”^message” 这个规则要根据自己修改，这个是指同步”message”开头的队列名称，我们配置时使用的应用于所有队列，所以表达式为”^”<br>官方set_policy说明参见</p><p><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#Policy_Management" target="_blank" rel="noopener">官方set_policy</a></p><p><a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">集群指南</a></p><hr><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><hr><div id="link10"></div><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p><a href="https://www.rabbitmq.com" target="_blank" rel="noopener">官网</a></p><p><a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html" target="_blank" rel="noopener">Java RabbitMQ Client Api 文档</a></p><p><a href="https://www.rabbitmq.com/api-guide.html" target="_blank" rel="noopener">RabbitMQ Java Api官方教程生肉</a></p><p><a href="https://blog.csdn.net/csdnzouqi/article/details/78926603#%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AFpublishing-messages" target="_blank" rel="noopener">RabbitMQ Java Api官方教程熟肉</a></p><p><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a></p><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p><p><a href="https://www.cnblogs.com/wyt007/p/9081931.html" target="_blank" rel="noopener">RabbitMQ集群</a></p><p><a href="http://www.cnblogs.com/flat_peach/archive/2013/04/07/3004008.html" target="_blank" rel="noopener">Rabbitmq集群高可用测试</a></p><p><a href="https://www.rabbitmq.com/rabbitmqctl.8.html" target="_blank" rel="noopener">Rabbitmqctl 文档</a></p><p><a href="https://blog.csdn.net/u011665991/article/details/89487510" target="_blank" rel="noopener">RabbitMQ系列文章</a></p></div><div class="post-share">分享到：</div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/csdn-breakthrough-download/" rel="next" title="csdn 突破正版链接直接下载"><i class="fa fa-chevron-left"></i> csdn 突破正版链接直接下载</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/change-linux-max-open-file/" rel="prev" title="Linux 修改最大打开文件数量">Linux 修改最大打开文件数量 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><div id="dsqjs"><section class="dsqjs-info"><p id="dsqjs-load-disqus" class="dsqjs-message">评论完整模式加载中...如果长时间无法加载，请针对 disq.us | disquscdn.com | disqus.com 启用代理</p></section></div></div></div><script type="text/javascript">window.DISQUS=null,new DisqusJS({shortname:"https-aphage-me",siteName:"Hi, aphage",identifier:"rabbitmq/",url:"https://aphage.me/rabbitmq/",api:"",apikey:"",admin:"",adminLabel:""})</script></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/yu_ban_mei_qin_9.jpg" alt="aphage"><p class="site-author-name" itemprop="name"><span style="opacity:.2">a</span>phage</p><p class="site-description motion-element" itemprop="description">你能抓到我么？</p></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/aphage" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up"><i class="fa fa-fw fa-github"></i></a></span></div><div class="feed-link motion-element"><a class="feed-rss" href="/atom.xml" rel="alternate" target="_blank"><i class="fa fa-rss"></i> <span>RSS 订阅</span></a></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">8</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-sa.png" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#当前版本"><span class="nav-number">1.</span> <span class="nav-text">当前版本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是MQ-为什么要使用MQ"><span class="nav-number">1.1.</span> <span class="nav-text">什么是MQ,为什么要使用MQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么选择RabbitMQ"><span class="nav-number">1.2.</span> <span class="nav-text">为什么选择RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ-对比"><span class="nav-number">1.2.1.</span> <span class="nav-text">MQ 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#知道了吗？为什么选择RabbitMQ！！！！！！"><span class="nav-number">1.2.2.</span> <span class="nav-text">知道了吗？为什么选择RabbitMQ！！！！！！</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么安装RabbitMQ"><span class="nav-number">1.3.</span> <span class="nav-text">怎么安装RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动服务RabbitMQ器"><span class="nav-number">1.3.1.</span> <span class="nav-text">启动服务RabbitMQ器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用命令"><span class="nav-number">1.3.2.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#User-用户"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">User | 用户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Access-Control-访问控制"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Access Control | 访问控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ怎么使用"><span class="nav-number">1.4.</span> <span class="nav-text">RabbitMQ怎么使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连接服务器"><span class="nav-number">1.4.1.</span> <span class="nav-text">连接服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明交换机和队列并绑定"><span class="nav-number">1.4.2.</span> <span class="nav-text">声明交换机和队列并绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明交换机"><span class="nav-number">1.4.3.</span> <span class="nav-text">声明交换机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ概念"><span class="nav-number">1.5.</span> <span class="nav-text">RabbitMQ概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AMQP中的消息路由"><span class="nav-number">1.5.2.</span> <span class="nav-text">AMQP中的消息路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchange-类型"><span class="nav-number">1.5.3.</span> <span class="nav-text">Exchange 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ消息事务"><span class="nav-number">1.6.</span> <span class="nav-text">RabbitMQ消息事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">1.6.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展知识"><span class="nav-number">1.6.2.</span> <span class="nav-text">扩展知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ消息确认"><span class="nav-number">1.7.</span> <span class="nav-text">RabbitMQ消息确认</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通Confirm模式"><span class="nav-number">1.7.1.</span> <span class="nav-text">普通Confirm模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量Confirm模式"><span class="nav-number">1.7.2.</span> <span class="nav-text">批量Confirm模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步Confirm模式"><span class="nav-number">1.7.3.</span> <span class="nav-text">异步Confirm模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ配置"><span class="nav-number">1.8.</span> <span class="nav-text">RabbitMQ配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ集群"><span class="nav-number">1.9.</span> <span class="nav-text">RabbitMQ集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rabbitmq集群高可用"><span class="nav-number">1.9.1.</span> <span class="nav-text">Rabbitmq集群高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单一模式：最简单的情况，非集群模式。"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">单一模式：最简单的情况，非集群模式。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#普通模式：默认的集群模式。"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">普通模式：默认的集群模式。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完结撒花"><span class="nav-number">1.10.</span> <span class="nav-text">完结撒花</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#帮助"><span class="nav-number">1.11.</span> <span class="nav-text">帮助</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"></div><div class="footer-inner"><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>托管于<a href="https://github.com/" target="_blank" rel="nofollow"> GitHub</a>. <a href="https://dash.cloudflare.com" target="_blank" rel="nofollow">cloudflare </a>提供 CDN 解析服务.</p><p>© <span itemprop="copyrightYear">2020</span> Hi, aphage. 由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动. Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.35. <a href="/sitemap.xml" target="_blank">站点地图</a>. .</p><p>Made with <i class="fa fa-heart throb" style="color:#d43f57"></i> by <span class="author" itemprop="copyrightHolder">aphage</span>.</p></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><canvas id="evanyou"></canvas><div id="aplayer-fixed"></div></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.35"></script><script>var serviceWorkerUri="/sw.js";"serviceWorker"in navigator?navigator.serviceWorker.register(serviceWorkerUri).then(function(){navigator.serviceWorker.controller?console.log("Assets cached by the controlling service worker."):console.log("Please reload this page to allow the service worker to handle network operations.")}).catch(function(e){console.log("ERROR: "+e)}):console.log("Service workers are not supported in the current browser.")</script></body></html>