<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, aphage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aphage.me/"/>
  <updated>2020-02-27T21:22:14.705Z</updated>
  <id>https://aphage.me/</id>
  
  <author>
    <name>aphage</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM 参数设置</title>
    <link href="https://aphage.me/jvm-parameters/"/>
    <id>https://aphage.me/jvm-parameters/</id>
    <published>2019-05-20T14:30:46.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<p><code>JDK8-废弃永久代（PermGen）迎来元空间（Metaspace）</code></p><p><code>移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</code></p><p>JVM内存为两块：PermanentSapce和HeapSpace</p><p>PermanentSapce：存放代码的(字节码)</p><p>HeapSpace：堆</p><p>其中HeapSpace= {Old + NEW {= Eden , from, to } }</p><p>一般设置一下内存大小和回收策略就行了</p><hr><a id="more"></a><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>-server：</p><p>一定要作为第一个参数，在多个 CPU 时性能佳，还有一种叫</p><p>-client:</p><p>的模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试，在 32 位环境下直接运行 Java 程序默认启用该模式。Server 模式的特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境，在具有 64 位能力的 JDK 环境下默认启用该模式，可以不配置该参数。</p><p>-Xms：</p><p>表示 Java 初始化堆的大小，-Xms 与-Xmx 设成一样的值，避免 JVM 反复重新申请内存，导致性能大起大落，默认值为物理内存的 1/64，默认（MinHeapFreeRatio参数可以调整）空余堆内存小于 40% 时，JVM 就会增大堆直到 -Xmx 的最大限制。</p><p>-Xmx：</p><p>表示最大 Java 堆大小，当应用程序需要的内存超出堆的最大值时虚拟机就会提示内存溢出，并且导致应用服务崩溃，因此一般建议堆的最大值设置为可用内存的最大值的80%。如何知道我的 JVM 能够使用最大值，使用 java -Xmx512M -version 命令来进行测试，然后逐渐的增大 512 的值,如果执行正常就表示指定的内存大小可用，否则会打印错误信息，默认值为物理内存的 1/4，默认（MinHeapFreeRatio参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到-Xms 的最小限制。</p><p>-Xss：</p><p>表示每个 Java 线程堆栈大小，JDK 5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。根据应用的线程所需内存大小进行调整，在相同物理内存下，减小这个值能生成更多的线程，但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。一般小的应用， 如果栈不是很深， 应该是128k 够用的，大的应用建议使用 256k 或 512K，一般不易设置超过 1M，要不然容易出现out ofmemory。这个选项对性能影响比较大，需要严格的测试。</p><p>-XX:NewSize：设置新生代内存大小。</p><p>-XX:MaxNewSize：设置最大新生代新生代内存大小</p><p><del>-XX:PermSize：设置持久代内存大小</del>JDK8 后被抛弃，使用-XX:MetaspaceSize替代，一般不需要调整</p><p><del>-XX:MaxPermSize：设置最大值持久代内存大小，永久代不属于堆内存，堆内存只包含新生代和老年代。</del>JDK8 后被抛弃，使用-XX:MaxMetaspaceSize替代,一般不需要调整</p><p><strong>-XX:MaxPermSize=size</strong></p><p>Sets the maximum permanent generation space size (in bytes). This option was deprecated in JDK 8, and superseded by the -XX:MaxMetaspaceSize option.</p><p><strong>-XX:PermSize=size</strong></p><p>Sets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it is exceeded. This option was deprecated un JDK 8, and superseded by the -XX:MetaspaceSize option.</p><p><strong>-XX:MaxMetaspaceSize=size</strong></p><p>Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size is not limited. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system.</p><p>The following example shows how to set the maximum class metadata size to 256 MB:</p><p>-XX:MaxMetaspaceSize=256m</p><p><strong>-XX:MetaspaceSize=size</strong></p><p>Sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform.</p><p>因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大</p><p>-XX:+AggressiveOpts：</p><p>作用如其名（aggressive），启用这个参数，则每当 JDK 版本升级时，你的 JVM 都会使用最新加入的优化技术（如果有的话）。</p><p>-XX:+DisableExplicitGC：</p><p>禁用System.gc() ,在 程序代码中不允许有显示的调用“System.gc()”。每次在到操作结束时手动调用 System.gc() 一下，付出的代价就是系统响应时间严重降低，就和关于 Xms，Xmx 里的解释的原理一样，这样去调用 GC 导致系统的 JVM 大起大落。</p><p>-Xmn：</p><p>新生代的内存空间大小，可以替代-XX:NewSize,-XX:MaxNewSize<br>对-XX:newSize、-XX:MaxnewSize两个参数同时进行配置（注意：JDK1.4之后才有该参数）。</p><p>-Duser.timezone=Asia/Shanghai：</p><p>设置用户所在时区。</p><p>-XX:NewRatio：</p><p>年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代），-XX:NewRatio=4 表示年轻代与年老代所占比值为 1:4，年轻代占整个堆栈的 1/5，Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p><p>-XX:SurvivorRatio：</p><p>Eden 区与 Survivor 区的大小比值，设置为 8，表示 2 个 Survivor 区（JVM 堆内存年轻代中默认有 2 个大小相等的 Survivor 区）与 1 个 Eden 区的比值为 2:8，即 1 个 Survivor 区占整个年轻代大小的 1/10。</p><p>-XX:+UseConcMarkSweepGC：</p><p>设置年老代为并发收集，即 CMS gc，这一特性只有 jdk1.5<br>后续版本才具有的功能，它使用的是 gc 估算触发和 heap 占用触发。我们知道频频繁的 GC 会造面 JVM<br>的大起大落从而影响到系统的效率，因此使用了 CMS GC 后可以在 GC 次数增多的情况下，每次 GC 的响应时间却很短，比如说使用了 CMS<br>GC 后经过 jprofiler 的观察，GC 被触发次数非常多，而每次 GC 耗时仅为几毫秒。</p><p>-XX:+UseParNewGC：</p><p>对新生代采用多线程并行回收，这样收得快，注意最新的 JVM 版本，当使用 -XX:+UseConcMarkSweepGC 时，-XX:UseParNewGC 会自动开启。因此，如果年轻代的并行 GC 不想开启，可以通过设置 -XX：-UseParNewGC 来关掉。</p><p>资料</p><p><a href="https://docs.oracle.com/cd/E22289_01/html/821-1274/configuring-the-default-jvm-and-java-arguments.html" target="_blank" rel="noopener">Configuring the Default JVM and Java Arguments官方文档</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">JVM 参数介绍官方文档</a></p><p><a href="https://blog.csdn.net/tree_ifconfig/article/details/81222196" target="_blank" rel="noopener">JVM中的-Xms -Xmx -XX:newSize -XX:MaxnewSize -Xmn -XX:PermSize -XX:MaxPermSize区别介绍</a></p><p><a href="https://blog.csdn.net/ljj_9/article/details/79145324" target="_blank" rel="noopener">生产环境的tomcat调优和jvm调化</a></p><p><a href="https://www.cnblogs.com/andy-zhou/p/5327288.html" target="_blank" rel="noopener">JVM调优总结，比较详细</a></p><p><a href="https://www.cnblogs.com/w-wfy/p/6415856.html" target="_blank" rel="noopener">java–jvm启动的参数</a></p><p><a href="https://www.cnblogs.com/sjxbg/p/9388615.html" target="_blank" rel="noopener">JVM垃圾回收机制与内存回收</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JDK8-废弃永久代（PermGen）迎来元空间（Metaspace）&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;JVM内存为两块：PermanentSapce和HeapSpace&lt;/p&gt;&lt;p&gt;PermanentSapce：存放代码的(字节码)&lt;/p&gt;&lt;p&gt;HeapSpace：堆&lt;/p&gt;&lt;p&gt;其中HeapSpace= {Old + NEW {= Eden , from, to } }&lt;/p&gt;&lt;p&gt;一般设置一下内存大小和回收策略就行了&lt;/p&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://aphage.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://aphage.me/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://aphage.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Failed to start LSB</title>
    <link href="https://aphage.me/Failed-to-start-LSB/"/>
    <id>https://aphage.me/Failed-to-start-LSB/</id>
    <published>2019-05-01T22:53:25.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<p>不知道怎么了，网络突然不行了</p><p>查了一下说是网卡的mac地址和配置文件的不一致</p><p>看了下我的网卡配置 /etc/sysconfig/network-scripts/ifcfg-ens11</p><p>我根本没有配置HWADDR 属性</p><p>看到其他地方说是NetworkManager 服务导致的</p><p>我先把他停止，然后启动网络服务，在重新启动网络管理服务，解决了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl start network</span><br><span class="line">systemctl start NetworkManager</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知道怎么了，网络突然不行了&lt;/p&gt;&lt;p&gt;查了一下说是网卡的mac地址和配置文件的不一致&lt;/p&gt;&lt;p&gt;看了下我的网卡配置 /etc/sysconfig/network-scripts/ifcfg-ens11&lt;/p&gt;&lt;p&gt;我根本没有配置HWADDR 属性&lt;/p&gt;&lt;p&gt;看到其他
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://aphage.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://aphage.me/tags/Linux/"/>
    
      <category term="CentOS7" scheme="https://aphage.me/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>Gradle 打包jar的几种方式</title>
    <link href="https://aphage.me/Gradle-Generate-Jar/"/>
    <id>https://aphage.me/Gradle-Generate-Jar/</id>
    <published>2019-05-01T22:53:25.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jar任务"><a href="#jar任务" class="headerlink" title="jar任务"></a>jar任务</h2><p>打包成一个Jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        &#x2F;&#x2F;添加依懒到打包文件</span><br><span class="line">        &#x2F;&#x2F;configurations.compile.collect &#123; it.isDirectory() ? it : zipTree(it) &#125;</span><br><span class="line">        configurations.runtime.collect&#123;zipTree(it)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes &#39;Main-Class&#39;: appMainClass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>打包成多个Jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes &#39;Main-Class&#39;: appMainClass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clearJar(type: Delete) &#123;</span><br><span class="line">    delete &#39;build&#x2F;libs&#x2F;lib&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    from configurations.runtime</span><br><span class="line">    into(&#39;build&#x2F;libs&#x2F;lib&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(type: Copy, dependsOn: [build, clearJar, copyJar])</span><br></pre></td></tr></table></figure><p>执行命令gradle release或者./gradlew relesse，可在build/libs查看生成的jar包</p><p>两种方式都各有缺陷，打包成一个Jar当依懒比较多情况下Jar包会很大，其它工程要要单独引用某个Jar不方便；打包成多个Jar没有启动脚本，不熟悉Java的新手不懂得运行。</p><h2 id="application插件"><a href="#application插件" class="headerlink" title="application插件"></a>application插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;application&#39;</span><br><span class="line">mainClassName &#x3D; appMainClass</span><br></pre></td></tr></table></figure><p>执行命令<code>gradle build</code>或者<code>./gradlew build</code>，查看<code>build/distributions</code>会有两个压缩文件，压缩文件包含了两个文件夹，bin为启动脚本，lib则是软件jar包和依赖。还可以执行<code>./gradlew installDist</code>生成未压缩文件目录<code>build/install</code>。<br>这种方式最为简单，不需要添加复杂的脚本，打包成多个jar并生成启动脚本可一键运行</p><h2 id="全部脚本参考"><a href="#全部脚本参考" class="headerlink" title="全部脚本参考"></a>全部脚本参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">def appMainClass &#x3D; &#39;HelloWorldKt&#39;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line">apply plugin: &#39;kotlin&#39;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line">archivesBaseName &#x3D; &#39;app&#39;</span><br><span class="line">&#x2F;&#x2F; 生成启动脚本打包</span><br><span class="line">&#x2F;&#x2F;apply plugin: &#39;application&#39;</span><br><span class="line">&#x2F;&#x2F;mainClassName &#x3D; appMainClass</span><br><span class="line"></span><br><span class="line">sourceCompatibility &#x3D; 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;</span><br><span class="line">    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions.jvmTarget &#x3D; &quot;1.8&quot;</span><br><span class="line">&#125;</span><br><span class="line">compileTestKotlin &#123;</span><br><span class="line">    kotlinOptions.jvmTarget &#x3D; &quot;1.8&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    configurations.runtime.each &#123; println it.path &#125;</span><br><span class="line">    println &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">    configurations.compile.each &#123; println it.path &#125;</span><br><span class="line">    println &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    from &#123;</span><br><span class="line">        &#x2F;&#x2F;添加依懒到打包文件</span><br><span class="line">        &#x2F;&#x2F;configurations.compile.collect &#123; it.isDirectory() ? it : zipTree(it) &#125;</span><br><span class="line">        configurations.runtime.collect &#123; zipTree(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes &#39;Main-Class&#39;: appMainClass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clearJar(type: Delete) &#123;</span><br><span class="line">    delete &#39;build&#x2F;libs&#x2F;lib&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    from configurations.runtime</span><br><span class="line">    into(&#39;build&#x2F;libs&#x2F;lib&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(type: Copy, dependsOn: [build, clearJar, copyJar])</span><br></pre></td></tr></table></figure><h2 id="Gradle-将依赖和资源文件打入jar包"><a href="#Gradle-将依赖和资源文件打入jar包" class="headerlink" title="Gradle - 将依赖和资源文件打入jar包"></a>Gradle - 将依赖和资源文件打入jar包</h2><p>用以下build.gradle打包出来的jar包，依赖是分离的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;commons-codec:commons-codec:1.4&#39;</span><br><span class="line">    compile &#39;commons-logging:commons-logging:1.1.1&#39;</span><br><span class="line">    compile &#39;com.google.code.gson:gson:2.4&#39;</span><br><span class="line">    compile &#39;org.apache.httpcomponents:httpclient:4.3.6&#39;</span><br><span class="line">    compile &#39;com.strategicgains:RestExpress:0.11.2&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-databind:2.6.4&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-core:2.6.4&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-annotations:2.6.4&#39;</span><br><span class="line">    compile &quot;ch.qos.logback:logback-core:1.1.3&quot;</span><br><span class="line">    compile &quot;ch.qos.logback:logback-classic:1.1.3&quot;</span><br><span class="line">    compile &#39;net.kencochrane.raven:raven-logback:6.0.0&#39;</span><br><span class="line">    compile &#39;net.kencochrane.raven:raven:6.0.0&#39;</span><br><span class="line">    compile &quot;org.slf4j:slf4j-api:1.7.13&quot;</span><br><span class="line">    compile &#39;com.rabbitmq:amqp-client:4.1.0&#39;</span><br><span class="line">    compile &#39;org.apache.commons:commons-lang3:3.4&#39;</span><br><span class="line">    compile &#39;commons-net:commons-net:3.4&#39;</span><br><span class="line">    compile &#39;org.zeromq:jeromq:0.3.5&#39;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    compile project(&#39;:tc-das&#39;)</span><br><span class="line">    compile project(&#39;:result-compare&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(</span><br><span class="line">                &quot;Manifest-Version&quot;: 1.0,</span><br><span class="line">                &quot;Main-Class&quot;: &quot;com.testbird.rio.Main&quot;,</span><br><span class="line">                &quot;Class-Path&quot;: configurations.compile.collect &#123; &quot;lib&#x2F;$&#123;it.name&#125;&quot; &#125;.join(&#39; &#39;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将build.gradle修改一下，就能将依赖和资源文件打入jar包了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;commons-codec:commons-codec:1.4&#39;</span><br><span class="line">    compile &#39;commons-logging:commons-logging:1.1.1&#39;</span><br><span class="line">    compile &#39;com.google.code.gson:gson:2.4&#39;</span><br><span class="line">    compile &#39;org.apache.httpcomponents:httpclient:4.3.6&#39;</span><br><span class="line">    compile &#39;com.strategicgains:RestExpress:0.11.2&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-databind:2.6.4&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-core:2.6.4&#39;</span><br><span class="line">    compile &#39;com.fasterxml.jackson.core:jackson-annotations:2.6.4&#39;</span><br><span class="line">    compile &quot;ch.qos.logback:logback-core:1.1.3&quot;</span><br><span class="line">    compile &quot;ch.qos.logback:logback-classic:1.1.3&quot;</span><br><span class="line">    compile &#39;net.kencochrane.raven:raven-logback:6.0.0&#39;</span><br><span class="line">    compile &#39;net.kencochrane.raven:raven:6.0.0&#39;</span><br><span class="line">    compile &quot;org.slf4j:slf4j-api:1.7.13&quot;</span><br><span class="line">    compile &#39;com.rabbitmq:amqp-client:4.1.0&#39;</span><br><span class="line">    compile &#39;org.apache.commons:commons-lang3:3.4&#39;</span><br><span class="line">    compile &#39;commons-net:commons-net:3.4&#39;</span><br><span class="line">    compile &#39;org.zeromq:jeromq:0.3.5&#39;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    compile project(&#39;:tc-das&#39;)</span><br><span class="line">    compile project(&#39;:result-compare&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(</span><br><span class="line">                &quot;Manifest-Version&quot;: 1.0,</span><br><span class="line">                &quot;Main-Class&quot;: &quot;com.testbird.rio.Main&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    from &#123; configurations.compile.collect &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    into(&#39;assets&#39;) &#123;</span><br><span class="line">        from &#39;assets&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.jianshu.com/p/5bb1e87df15f" target="_blank" rel="noopener">Gradle 打包jar的几种方式</a><br><a href="https://www.cnblogs.com/jyx140521/p/6855210.html" target="_blank" rel="noopener">Gradle - 将依赖和资源文件打入jar包</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jar任务&quot;&gt;&lt;a href=&quot;#jar任务&quot; class=&quot;headerlink&quot; title=&quot;jar任务&quot;&gt;&lt;/a&gt;jar任务&lt;/h2&gt;&lt;p&gt;打包成一个Jar&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    from &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#x2F;&amp;#x2F;添加依懒到打包文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#x2F;&amp;#x2F;configurations.compile.collect &amp;#123; it.isDirectory() ? it : zipTree(it) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        configurations.runtime.collect&amp;#123;zipTree(it)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    manifest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        attributes &amp;#39;Main-Class&amp;#39;: appMainClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://aphage.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://aphage.me/tags/JAVA/"/>
    
      <category term="Gradle" scheme="https://aphage.me/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Linux 修改最大打开文件数量</title>
    <link href="https://aphage.me/change-linux-max-open-file/"/>
    <id>https://aphage.me/change-linux-max-open-file/</id>
    <published>2019-05-01T22:53:25.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br></pre></td></tr></table></figure><p>临时修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 65535</span><br></pre></td></tr></table></figure><a id="more"></a><p>永久修改</p><p>在<code>/etc/security/limits.conf</code>加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><p><code>*</code> 表示所有用户</p><p>注意用户最大打开文件数量不能大于系统规定的打开数量</p><p>查看系统最大打开文件数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><p>临时修改系统最大打开文件数量直接修改上面的文件中的数字即可</p><p>永久修改</p><p>在<code>/etc/sysctl.conf</code>加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max &#x3D; 6553560</span><br></pre></td></tr></table></figure><p>如果要通过安全shell（SSH）访问</p><p>还应编辑<code>/etc/ssh/sshd_config</code>并取消注释以下行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#UseLogin no</span><br></pre></td></tr></table></figure><p>并将其值设置yes为如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseLogin yes</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh restart</span><br></pre></td></tr></table></figure><p>重新启动计算机以使限制生效并使用以下命令验证是否已设置新限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure><p>With systemd (Recent Linux Distributions)</p><p>比如Centos 7</p><p>可以修改<code>/etc/systemd/system.conf</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultLimitNOFILE</span><br></pre></td></tr></table></figure><p>重启后生效</p><p>针对单独的进程可以设置<code>/etc/systemd/system/xxx.service.d/limits.conf</code></p><p><code>xxx</code>是进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">LimitNOFILE&#x3D;64000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ulimit&lt;/span&gt; -n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;临时修改&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ulimit&lt;/span&gt; -n 65535&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://aphage.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://aphage.me/tags/Linux/"/>
    
      <category term="CentOS7" scheme="https://aphage.me/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 入门教程</title>
    <link href="https://aphage.me/rabbitmq/"/>
    <id>https://aphage.me/rabbitmq/</id>
    <published>2019-05-01T22:53:25.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#link1">什么是MQ为什么使用MQ</a></li><li><a href="#link2">为什么选择RabbitMQ</a></li><li><a href="#link3">怎么安装RabbitMQ</a></li><li><a href="#link4">RabbitMQ怎么使用</a></li><li><a href="#link5">RabbitMQ概念</a></li><li><a href="#link6">RabbitMQ消息事物</a></li><li><a href="#link7">RabbitMQ消息确认</a></li><li><a href="#link8">RabbitMQ配置</a></li><li><a href="#link9">RabbitMQ集群</a></li><li><a href="#link10">帮助</a></li></ul><h1 id="当前版本"><a href="#当前版本" class="headerlink" title="当前版本"></a>当前版本</h1><blockquote><ul><li>CentOS 7</li><li>Erlang 21.x</li><li>RabbitMQ 3.7.14</li></ul></blockquote><a id="more"></a><div id="link1"></div><h2 id="什么是MQ-为什么要使用MQ"><a href="#什么是MQ-为什么要使用MQ" class="headerlink" title="什么是MQ,为什么要使用MQ"></a>什么是MQ,为什么要使用MQ</h2><p>哈，MQ你都不知道，你还来这里，茨~ 快去百度啦</p><p>为什么使用MQ</p><p>话说，你都不知道为什么使用MQ，那你还来这里干嘛？</p><hr><div id="link2"></div><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>现在的市面上有很多MQ可以选择，比如ActiveMQ、ZeroMQ、Appche Qpid，那问题来了为什么要选择RabbitMQ？</p><blockquote><ol><li>除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；</li><li>可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；</li><li>高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开&gt; 发4. 的语言，天生自带高并发光环，和高可用特性；</li><li>集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；</li><li>社区活跃度高，根据网上资料来看，RabbitMQ也是首选；</li></ol></blockquote><hr><h3 id="MQ-对比"><a href="#MQ-对比" class="headerlink" title="MQ 对比"></a>MQ 对比</h3><p>我们先来看一些数据</p><p>阿里官网对比</p><table><thead><tr><th>功能</th><th>消息队列 RocketMQ</th><th>Apache RocketMQ（开源）</th><th>消息队列 Kafka</th><th>Apache Kafka（开源）</th><th>RabbitMQ（开源）</th></tr></thead><tbody><tr><td>安全防护</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>主子账号支持</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>可靠性</td><td>同步刷盘 - 同步双写 - 超3份数据副本 - 99.99999999%</td><td>- 同步刷盘 - 异步刷盘 -</td><td>同步刷盘 - 同步双写 - 超3份数据副本 - 99.99999999%</td><td>异步刷盘，丢数据概率高</td><td>同步刷盘</td></tr><tr><td>可用性</td><td>- 非常好，99.95% - Always Writable</td><td>好</td><td>- 非常好，99.95% - Always Writable</td><td>好</td><td>好</td></tr><tr><td>横向扩展能力</td><td>- 支持平滑扩展 - 支持百万级 QPS</td><td>支持</td><td>- 支持平滑扩展 - 支持百万级 QPS</td><td>支持</td><td>- 集群扩容依赖前端 - LVS 负载均衡调度</td></tr><tr><td>Low Latency</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消费模型</td><td>Push / Pull</td><td>Push / Pull</td><td>Push / Pull</td><td>Pull</td><td>Push / Pull</td></tr><tr><td>定时消息</td><td>支持（可精确到秒级）</td><td>支持（只支持18个固定 Level）</td><td>暂不支持</td><td>不支持</td><td>支持</td></tr><tr><td>事务消息</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>顺序消息</td><td>支持</td><td>支持</td><td>暂不支持</td><td>支持</td><td>不支持</td></tr><tr><td>全链路消息轨迹</td><td>支持</td><td>不支持</td><td>暂不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息堆积能力</td><td>百亿级别 不影响性能</td><td>百亿级别 影响性能</td><td>百亿级别 不影响性能</td><td>影响性能</td><td>影响性能</td></tr><tr><td>消息堆积查询</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息回溯</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息重试</td><td>支持</td><td>支持</td><td>暂不支持</td><td>不支持</td><td>支持</td></tr><tr><td>死信队列</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>性能（常规）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>非常好 百万级 QPS</td><td>一般 万级 QPS</td></tr><tr><td>性能（万级 Topic 场景）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>低</td><td>低</td></tr><tr><td>性能（海量消息堆积场景）</td><td>非常好 百万级 QPS</td><td>非常好 十万级 QPS</td><td>非常好 百万级 QPS</td><td>低</td><td>低</td></tr></tbody></table><hr><table><thead><tr><th>xxxxxxxxxxxxxxxxxx</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMq</th><th>ZeroMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>关注度</td><td>高</td><td>高</td><td>中</td><td>中</td><td>高</td></tr><tr><td>成熟度</td><td>成熟</td><td>成熟</td><td>比较成熟</td><td>不成熟</td><td>成熟</td></tr><tr><td>所属社区/公司</td><td>Apache</td><td>Mozilla Public License</td><td>Alibaba Apache</td><td></td><td></td></tr><tr><td>社区活跃度</td><td>高</td><td>高</td><td>中</td><td>低</td><td>高</td></tr><tr><td>文档</td><td>多</td><td>多</td><td>中</td><td>中</td><td>多</td></tr><tr><td>特点</td><td>功能齐全，被大量开源项目使用</td><td>由于Erlang 语言的并发能力，性能很好</td><td>各个环节分布式扩展设计，主从 HA；支持上万个队列；多种消费模式；性能很好</td><td>低延时，高性能，最高 43万条消息每秒</td><td></td></tr><tr><td>授权方式</td><td>开源</td><td>开源</td><td>开源</td><td>开源</td><td>开源</td></tr><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>C</td><td></td></tr><tr><td>支持的协议</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>AMQP 自己定义的一套(社区提供JMS–不成熟)</td><td>TCP、UDP</td><td></td><td></td></tr><tr><td>客户端支持语言</td><td>Java、C、C++、Python、PHP、Perl、.net 等</td><td>Java、C、C++、Python、PHP、Perl、.net 等</td><td>Java C++（不成熟）</td><td>python java、 php、.net 等</td><td></td></tr><tr><td>持久化</td><td>内存、文件、数据库</td><td>内存、文件</td><td>磁盘文件</td><td>在消息发送端保存</td><td></td></tr><tr><td>事务</td><td>支持</td><td>不支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>集群</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>负载均衡</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>管理界面</td><td>一般</td><td>好</td><td>无社区有 web console 实现</td><td>无</td><td></td></tr><tr><td>部署方式</td><td>独立、嵌入</td><td>独立</td><td>独立</td><td>独立</td><td></td></tr><tr><td>顺序</td><td>无法保证严格的顺序</td><td></td><td>保证严格的消费顺序</td><td></td><td></td></tr><tr><td>优点</td><td>成熟的产品，已经在很多公司得到应用（非大规模场景）。有较多的文档。各种协议支持较好，有多重语言的成熟的客户端；</td><td>由于erlang语言的特性，mq 性能较好；管理界面较丰富，在互联网公司也有较大规模的应用；支持amqp系诶，有多中语言且支持 amqp 的客户端可用</td><td>模型简单，接口易用（JMS 的接口很多场合并不太实用）。在阿里大规模应用。目前支付宝中的余额宝等新兴产品均使用rocketmq。集群规模大概在50 台左右，单日处理消息上百亿；性能非常好，可以大量堆积消息在broker 中；支持多种消费，包括集群消费、广播消费等。开发度较活跃，版本更新很快。</td><td></td><td></td></tr><tr><td>缺点</td><td>根据其他用户反馈，会出莫名其妙的问题，切会丢失消息。 其重心放到activemq6.0 产品—apollo 上去了，目前社区不活跃，且对 5.x 维护较少;Activemq 不适合用于上千个队列的应用场景</td><td>erlang语言难度较大。集群不支持动态扩展。</td><td>没有在 mq 核心中去实现JMS 等接口</td><td></td><td></td></tr></tbody></table><hr><h3 id="知道了吗？为什么选择RabbitMQ！！！！！！"><a href="#知道了吗？为什么选择RabbitMQ！！！！！！" class="headerlink" title="知道了吗？为什么选择RabbitMQ！！！！！！"></a>知道了吗？为什么选择RabbitMQ！！！！！！</h3><p><strong>(小声的说：其实！！！我也没用过MQ，各大厂商都实现了一套，所以我准备选择一个先了解一下)</strong></p><p><strong>为什么选择RabbitMQ呢？</strong></p><blockquote><ul><li><strong>因为我也是第一次接触MQ，选择的原因嘛，是RabbitMQ时间比较久了，资料比较多，刚入手肯定选择资料比较多的最好</strong></li><li><strong>还有Rabbit是兔子的意思嘛，一想到兔子，很可爱啊！！！</strong></li></ul></blockquote><hr><div id="link3"></div><h2 id="怎么安装RabbitMQ"><a href="#怎么安装RabbitMQ" class="headerlink" title="怎么安装RabbitMQ"></a>怎么安装RabbitMQ</h2><p>打开<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">官网</a>看了吗？</p><p>Download + Installation</p><p>哈！！！没看到，你网速太差了吧，那你等一下吧！</p><p>还是没看到！哦，那你点击一下<a href="https://www.rabbitmq.com/#getstarted" target="_blank" rel="noopener">我</a>吧！</p><p>啊<del>~ ~别点了</del>啊<del>~</del>～(￣▽￣～)</p><blockquote><p>我怀疑你在开车，但是我没有证据</p></blockquote><hr><p>OK，现在到<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">这里</a>了</p><p>我的是CentOS7 所以我点击<a href="https://www.rabbitmq.com/install-rpm.html" target="_blank" rel="noopener">这个</a></p><p>其他的系统自己研究了~ RabbitMQ 是Erlange开发了，所以要先安装Erlang，版本有要求哦</p><p>进来后看到<a href="https://www.rabbitmq.com/install-rpm.html#install-erlang" target="_blank" rel="noopener">Install Erlang</a></p><p>下面有一个<a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">a package</a> 的一个链接，点击跳转到了Github</p><p>往下面拉，这里我选择最新版本的Erlang 源，Erlang 21.x，当前版本的RabbitMQ3.7.14 也要求Erlang &gt;= 19.3</p><p>在往下拉，可以看到指定版本的Erlang 安装源</p><p>源安装好像有两种 Package Cloud、Bintray Yum Repositories</p><p>我选择第一种的，但是我没有操作这个<br>Package Cloud supports a variety of options for RPM package installation: from Yum configuration to shell scripts to Chef and Puppet.</p><p>See Package Cloud repository installation page for details.</p><p>也安装好了~嘛 再往下拉就能看到Bintray Yum Repositories，也可以用这个源安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># In &#x2F;etc&#x2F;yum.repos.d&#x2F;rabbitmq_erlang.repo</span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name&#x3D;rabbitmq_erlang</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;el&#x2F;7&#x2F;$basearch</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;gpgkey</span><br><span class="line">sslverify&#x3D;1</span><br><span class="line">sslcacert&#x3D;&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">metadata_expire&#x3D;300</span><br><span class="line">  </span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name&#x3D;rabbitmq_erlang-source</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;el&#x2F;7&#x2F;SRPMS</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang&#x2F;gpgkey</span><br><span class="line">sslverify&#x3D;1</span><br><span class="line">sslcacert&#x3D;&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;ca-bundle.crt</span><br><span class="line">metadata_expire&#x3D;300</span><br></pre></td></tr></table></figure><p>配置好后就安装了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y erlang</span><br></pre></td></tr></table></figure><p>安装好Erlang后开始安装RabbitMQ了</p><p>我们回到<a href="https://www.rabbitmq.com/install-rpm.html#bintray" target="_blank" rel="noopener">这里，快点击我啊~</a></p><p>这里使用Bintray 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;signing-keys&#x2F;releases&#x2F;download&#x2F;2.0&#x2F;rabbitmq-release-signing-key.asc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># In &#x2F;etc&#x2F;yum.repos.d&#x2F;rabbitmq.repo</span><br><span class="line">[bintray-rabbitmq-server]</span><br><span class="line">name&#x3D;bintray-rabbitmq-rpm</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;dl.bintray.com&#x2F;rabbitmq&#x2F;rpm&#x2F;rabbitmq-server&#x2F;v3.7.x&#x2F;el&#x2F;7&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure><p>写完配置后，安装，没有指定版本号默认安装最新版,我这里的是 <strong>3.7.14</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y rabbitmq-server.noarch</span><br></pre></td></tr></table></figure><h3 id="启动服务RabbitMQ器"><a href="#启动服务RabbitMQ器" class="headerlink" title="启动服务RabbitMQ器"></a>启动服务RabbitMQ器</h3><p>设置开机启动，默认是不会开机启动，大家自己选择</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p>启动RabbitMQ，Centos7 已经使用systemctl 替代 service 命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重新启动</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p>也可是使用RabbitMQ 提供的命令查看状态，更多关于rabbitmqctl 命令请<a href="https://www.rabbitmq.com/rabbitmqctl.8.html" target="_blank" rel="noopener">点击这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure><p>我选择开启Web 管理插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line">  </span><br><span class="line">rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 注意：插件的启用和关闭都不会影响当前运行rabbitmq节点。必须重新启动之后才会影响。</span></span><br></pre></td></tr></table></figure><p>打开 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p>输入guest guest</p><p>默认的用户guest只能在安装RabbitMQ的机器上登录，在其他机器登录需要新增用户！,当然利用配置文件也可以实现让guest用户在其他机器登陆！！</p><p>这里我选择新建用户</p><p>添加用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user username password</span><br></pre></td></tr></table></figure><p>设置用户标签（administrator），用户标签的用处主要是管理插件使用的，设置administrator 是让这个用户可以访问 Web端管理程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags username administrator</span><br></pre></td></tr></table></figure><p>设置 虚拟主机权限，RabbitMQ 是使用虚拟主机隔离的，每一个虚拟主机都用自己的交换机和队列，每个虚拟主机互相隔离</p><p>/ 是默认的虚拟主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions username -p / <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p>设置完后就可以远程使用这个用户登录Web 管理端了</p><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="User-用户"><a href="#User-用户" class="headerlink" title="User | 用户"></a><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management" target="_blank" rel="noopener">User | 用户</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户列表</span></span><br><span class="line">rabbitctl list_users</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user username password</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">rabbitmqctl delete_user username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">rabbitmqctl change_password username password</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清除密码</span></span><br><span class="line">rabbitmqcaltl clear_password username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置标签</span></span><br><span class="line">rabbitmqctl set_user_tags username administrator</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清空标签</span></span><br><span class="line">rabbitmqctl set_user_tags username</span><br></pre></td></tr></table></figure><h4 id="Access-Control-访问控制"><a href="#Access-Control-访问控制" class="headerlink" title="Access Control | 访问控制"></a><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#Access_Control" target="_blank" rel="noopener">Access Control | 访问控制</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虚拟主机列表</span></span><br><span class="line">rabbitmqctl list_vhosts</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加虚拟主机</span></span><br><span class="line">rabbitmqctl add_vhost vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除虚拟主机</span></span><br><span class="line">rabbitmqctl delete_vhost vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置权限用户</span></span><br><span class="line">rabbitmqctl set_permissions -p vhost username <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#清空用户权限</span></span><br><span class="line">rabbitmqctl clear_permissions -p vhost username</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 虚拟主机下的用户</span></span><br><span class="line">rabbitmqctl list_permissions -p vhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 用户下的虚拟主机</span></span><br><span class="line">rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure><hr><div id="link4"></div><h2 id="RabbitMQ怎么使用"><a href="#RabbitMQ怎么使用" class="headerlink" title="RabbitMQ怎么使用"></a>RabbitMQ怎么使用</h2><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>我使用的是Java 客户端 其他语言自己查阅官方文档</p><p>根据<a href="https://www.rabbitmq.com/java-client.html" target="_blank" rel="noopener">官方文档</a></p><p>我们要引入客户端</p><p>如果使用Maven</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>如果使用Gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &#39;com.rabbitmq:amqp-client:5.7.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来到<a href="https://www.rabbitmq.com/api-guide.html" target="_blank" rel="noopener">api文档</a>，看看Java怎么使用RabbitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">// "guest"/"guest" by default, limited to localhost connections</span></span><br><span class="line">factory.setUsername(userName);</span><br><span class="line">factory.setPassword(password);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(hostName);</span><br><span class="line">factory.setPort(portNumber);</span><br><span class="line">  </span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><table><thead><tr><th>Property</th><th>Default Value</th></tr></thead><tbody><tr><td>Username</td><td>“guest”</td></tr><tr><td>Password</td><td>“guest”</td></tr><tr><td>Virtual host</td><td>“/“</td></tr><tr><td>Hostname</td><td>“localhost”</td></tr><tr><td>port</td><td>5672 for regular connections, 5671 for connections that use TLS</td></tr></tbody></table><p>还可以使用URLs方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@hostName:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>我使用URLs方式，如果你要连接到默认的虚拟主机/，需要将/转义也就是%2F，其他不用</p><p>这里我直接写测试类里面了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aphage</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String uri = <span class="string">"amqp://%s:%s@%s:%d/%s"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"192.168.92.128"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = AMQP.PROTOCOL.PORT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME= <span class="string">"Aqua"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"Aqua"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VHOST = <span class="string">"%2F"</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory factory=<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(String.format(uri,USERNAME,PASSWORD,HOST,PORT,VHOST));</span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=conn)conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明交换机和队列并绑定"><a href="#声明交换机和队列并绑定" class="headerlink" title="声明交换机和队列并绑定"></a>声明交换机和队列并绑定</h3><p>声明交换机和队列的时候分为两种情况</p><ol><li>声明的交换机和队列不存在，就会创建</li><li>如果存在，就不会</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><ol><li>一种持久的，非自动交换的“直接”类型</li><li>具有生成名称的非持久，独占，自动删除队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><ol><li>一种持久的，非自动交换的“直接”类型</li><li>具有已知名称的持久，非独占，非自动删除队列</li></ol><h3 id="声明交换机"><a href="#声明交换机" class="headerlink" title="声明交换机"></a>声明交换机</h3><p>根据上面的代码，我们先来声明一些交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. 交换机名称</span></span><br><span class="line"><span class="comment">    * 2. 交换机类型</span></span><br><span class="line"><span class="comment">    * 3. 是否永久存在，false 为临时重启消失</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//直接类型</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"direct-forever"</span>, BuiltinExchangeType.DIRECT,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"direct-temporary"</span>, BuiltinExchangeType.DIRECT,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//广播类型 routing key 忽略无效</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"fanout-forever"</span>, BuiltinExchangeType.FANOUT,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"fanout-temporary"</span>, BuiltinExchangeType.FANOUT,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//广播类型 routing key 模糊匹配</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"topic-forever"</span>, BuiltinExchangeType.TOPIC,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"topic-temporary"</span>, BuiltinExchangeType.TOPIC,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//使用键值对匹配</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">"headers-forever"</span>, BuiltinExchangeType.HEADERS,<span class="keyword">true</span>);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">"headers-temporary"</span>, BuiltinExchangeType.HEADERS,<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>交换机类型分为四种 direct、fanout、topic、header（这个性能最差）</li><li>channel 官方建议不要多线程共享，最好一个线程使用一个channel</li></ul></blockquote><p>然后登陆Web 管理界面查看</p><p><a href="http://192.168.92.128:15672/#/exchanges" target="_blank" rel="noopener">http://192.168.92.128:15672/#/exchanges</a></p><p>发现已经有我们声明的交换机了</p><p>其中还有一些默认的交换机</p><p>我们也可以看到交换机是在虚拟主机中的、每个虚拟主机互相隔离</p><p>我们也发现在Features列，永久的交换机是带有D标签的</p><hr><p>接下来我们来声明队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queue - 队列的名称</span></span><br><span class="line"><span class="comment">    * durable - 如果我们声明一个持久队列，则为true（队列将在服务器重启后继续存在）</span></span><br><span class="line"><span class="comment">    * exclusive - 如果我们声明一个独占队列（仅限于此连接），则为true</span></span><br><span class="line"><span class="comment">    * autoDelete - 如果我们声明一个自动删除队列，则为true（服务器将在不再使用时将其删除）,消费者断开连接时是否删除队列</span></span><br><span class="line"><span class="comment">    * arguments - 队列的其他属性（构造参数）</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    channel.queueDeclare(<span class="string">"Aqua-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"fanout1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"fanout2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"topic3-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"headers1-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">"headers2-forever"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//主动声明一个服务器命名的独占，自动删除，非持久队列。</span></span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    System.out.println(queueName);</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用System.in.read 进行阻塞</p><p>打开 <a href="http://192.168.92.128:15672/#/queues" target="_blank" rel="noopener">http://192.168.92.128:15672/#/queues</a></p><p>我们可以看到我们的队列已经出来了，也有一些临时队列</p><p>声明队列也就两个api 函数</p><p>当我们点击结束进程的时候，断开连接了，临时队列就会自动删除</p><p>队列也有了，接下来就是和交换机绑定了，不然发送的数据没办法进入队列</p><p>因为exchange 是负责数据转发的，而队列（queue）只是保存数据的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel=conn.createChannel();</span><br><span class="line">    <span class="comment">//队列绑定交换机，一个队列可绑定多个交换机</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queue - 队列的名称</span></span><br><span class="line"><span class="comment">    * exchange - 交易所的名称</span></span><br><span class="line"><span class="comment">    * routingKey - 用于绑定的路由密钥</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到直接交换机</span></span><br><span class="line">    channel.queueBind(<span class="string">"Aqua-forever"</span>,<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播(fanout类型，对Routing Key无效)</span></span><br><span class="line">    channel.queueBind(<span class="string">"fanout1-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"fanout2-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播 routing key 模糊匹配</span></span><br><span class="line">    channel.queueBind(<span class="string">"topic1-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.#"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"topic2-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.mea.*"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"topic3-forever"</span>,<span class="string">"topic-forever"</span>,<span class="string">"Aqua.suki.*"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//绑定到广播(fanout类型，对Routing Key无效)</span></span><br><span class="line">    channel.queueBind(<span class="string">"fanout1-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"fanout2-forever"</span>,<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>);</span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"x-match"</span>, <span class="string">"any"</span>);<span class="comment">//这代表消息携带的Hash是需要全部匹配键值(all)，还是仅匹配一个键值(any)就可以了</span></span><br><span class="line">    map.put(<span class="string">"xxx"</span>,<span class="string">"111"</span>);</span><br><span class="line">    map.put(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"headers1-forever"</span>,<span class="string">"headers-forever"</span>,<span class="string">""</span>,map);</span><br><span class="line">    map.put(<span class="string">"x-match"</span>, <span class="string">"all"</span>);</span><br><span class="line">    channel.queueBind(<span class="string">"headers2-forever"</span>,<span class="string">"headers-forever"</span>,<span class="string">""</span>,map);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来发送消息（生产消息）到服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">    <span class="comment">//发送消息(生产消息)</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//routing key 直接忽略</span></span><br><span class="line">    channel.basicPublish(<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"fanout-forever"</span>,<span class="string">"Aqua-2"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    topic路由器的关键在于定义路由键，定义routingKey名称不能超过255字节，使用“.”作为分隔符，例如：com.mq.rabbit.error。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    消费消息的时候routingKey可以使用下面字符匹配消息：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    "*"匹配一个分段(用“.”分割)的内容；</span></span><br><span class="line"><span class="comment">    "#"匹配0和多个字符；</span></span><br><span class="line"><span class="comment">    例如发布了一个“com.mq.rabbit.error”的消息：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    能匹配上的路由键：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    cn.mq.rabbit.*</span></span><br><span class="line"><span class="comment">    cn.mq.rabbit.#</span></span><br><span class="line"><span class="comment">    #.error</span></span><br><span class="line"><span class="comment">    cn.mq.#</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    不能匹配上的路由键：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    cn.mq.*</span></span><br><span class="line"><span class="comment">    *.error</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    所以如果想要订阅所有消息，可以使用“#”匹配。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.hello"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.mea.suki"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"topic-forever"</span>,<span class="string">"Aqua.suki.me"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"xxx"</span>,<span class="string">"111"</span>);</span><br><span class="line">    channel.basicPublish(<span class="string">"headers-forever"</span>,<span class="string">""</span>,<span class="keyword">new</span> AMQP.BasicProperties().builder().headers(map).build(),getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        throws IOException;</span></span><br><span class="line"><span class="comment">    void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        throws IOException;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    他们共有的参数分别是：</span></span><br><span class="line"><span class="comment">    exchange：交换机名称</span></span><br><span class="line"><span class="comment">    routingKey：路由键</span></span><br><span class="line"><span class="comment">    props：消息属性字段，比如消息头部信息等等</span></span><br><span class="line"><span class="comment">    body：消息主体部分</span></span><br><span class="line"><span class="comment">    除此之外，还有mandatory和immediate这两个参数，鉴于RabbitMQ3.0不再支持immediate标志，因此我们重点讨论mandatory标志</span></span><br><span class="line"><span class="comment">    mandatory的作用：</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    当mandatory标志位设置为true时，如果exchange根据自身类型和消息routingKey无法找到一个合适的queue存储消息，那么broker会调用basic.return方法将消息返还给生产者;</span></span><br><span class="line"><span class="comment">    当mandatory设置为false时，出现上述情况broker会直接将消息丢弃;通俗的讲，mandatory标志告诉broker代理服务器至少将消息route到一个队列中，否则就将消息return给发送者;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Return(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里我们尝试发送无法路由的数据</span></span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-tietie"</span>,<span class="keyword">true</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    channel.addReturnListener((i, s, s1, s2, basicProperties, bytes) -&gt;</span><br><span class="line">            System.out.println(String.format(<span class="string">"replyCode=%d replyText=%s exchange=%s routingKey=%s body=%s"</span>,i,s,s1,s2,<span class="keyword">new</span> String(bytes,<span class="string">"UTF-8"</span>)))</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">" : Hello Aqua!!!!!!!!!!!!! prpr!!!!!!!!!!!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后可以看到控制台输出无法路由的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replyCode&#x3D;312 replyText&#x3D;NO_ROUTE exchange&#x3D;direct-forever routingKey&#x3D;Aqua-tietie body&#x3D;2019-05-14 17:00:53 : Hello Aqua!!!!!!!!!!!!! prpr!!!!!!!!!!!!!</span><br></pre></td></tr></table></figure><p>打开 <a href="http://192.168.92.128:15672/#/queues" target="_blank" rel="noopener">http://192.168.92.128:15672/#/queues</a> 可以看到数据已经到达队列中了</p><hr><p>下面我们可以从消息队列中取数据了，取数据比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.队列名称</span></span><br><span class="line"><span class="comment">        * 2. auto ack 自动确认</span></span><br><span class="line"><span class="comment">        * 3. consumerTag 取消回调的时候用的</span></span><br><span class="line"><span class="comment">        * 4. 接受消息回调</span></span><br><span class="line"><span class="comment">        * 5. 回调被取消的回调 例如队列被删除，或者在集群方案中，队列所在的节点失败</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        channel.basicConsume(<span class="string">"Aqua-forever"</span>,<span class="keyword">false</span>,<span class="string">"Aqua-listened-1"</span>,(s, delivery) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"tag: %s exchange: %s routing key: %s"</span>,s,delivery.getEnvelope().getExchange(),delivery.getEnvelope().getRoutingKey()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"msg: %s"</span>,<span class="keyword">new</span> String(delivery.getBody(),<span class="string">"UTF-8"</span>)));</span><br><span class="line">  </span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125;,s -&gt; System.out.println(<span class="string">"监听被取消: "</span>+ s));</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//这里我们没有进行确认，当与服务器断开连接，数据将会重新放回队列</span></span><br><span class="line">        <span class="comment">//让其他消费者进行消费</span></span><br><span class="line">        channel.basicConsume(<span class="string">"fanout1-forever"</span>,<span class="keyword">false</span>,<span class="string">"Aqua-listened-2"</span>,(s, delivery) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"tag: %s exchange: %s routing key: %s"</span>,s,delivery.getEnvelope().getExchange(),delivery.getEnvelope().getRoutingKey()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"msg: %s"</span>,<span class="keyword">new</span> String(delivery.getBody(),<span class="string">"UTF-8"</span>)));</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span></span><br><span class="line">        &#125;,s -&gt; System.out.println(<span class="string">"监听被取消: "</span>+ s));</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//也可是使用DefaultConsumer 官方文档用的就是这个</span></span><br><span class="line"><span class="comment">//        channel.basicConsume("Aqua-forever",false,"Aqua-listened",new DefaultConsumer(channel)&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                channel.basicAck(envelope.getDeliveryTag(),false);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">  </span><br><span class="line">        channel.addShutdownListener(e -&gt;</span><br><span class="line">            System.out.println(String.format(<span class="string">"连接关闭 %s %b"</span>,e.getMessage(),e.isHardError()))</span><br><span class="line">        );</span><br><span class="line">  </span><br><span class="line">        System.in.read();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果autoAck设置为false，需要调用basicAck 进行确认，未确认的将放到未确认队列，如果此时客户端断开连接，将重新放回原队列</p><p>如果autoAck设置为true，则服务器发送消息后，将消息从客户端移除</p><p><strong>需要查阅API <a href="#帮助">请点击</a></strong></p><hr><div id="link5"></div><h2 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>看图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png" alt="我是图片"></p><ol><li>Message</li></ol><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><ol start="2"><li>Publisher</li></ol><p>消息的生产者，就是发送消息的，也是一个向交换器发布消息的客户端应用程序。</p><ol start="3"><li>Exchange</li></ol><p>交换器，就是转发消息的，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><ol start="4"><li>Binding</li></ol><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><p>队列绑定交换机，一个队列可以绑定多个交换机，一个交换机也可以对应多个队列，多对多关系</p><ol start="5"><li>Queue</li></ol><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ol start="6"><li>Connection</li></ol><p>网络连接，比如一个TCP连接。</p><ol start="7"><li>Channel</li></ol><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p>其实是一个Channel对应一条TCP连接，还有官方建议不要多线程共享Channel，最好是一个线程对应一个Channel</p><ol start="8"><li>Consumer</li></ol><p>接收消息的，消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ol start="9"><li>Virtual Host</li></ol><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的<br>RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ol start="10"><li>Broker</li></ol><p>表示消息队列服务器实体。</p><h3 id="AMQP中的消息路由"><a href="#AMQP中的消息路由" class="headerlink" title="AMQP中的消息路由"></a>AMQP中的消息路由</h3><p><img src="https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png" alt="我是图片"></p><p>生产者发送消息到交换机，交换机根据交换机类型和参数、绑定的队列，转发到对应的队列</p><p>消费者去队列取出数据</p><h3 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h3><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路<br>由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型</p><ol><li>direct</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-13db639d2c22f2aa.png" alt="我是图片"></p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><ol start="2"><li>fanout</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-2f509b7f34c47170.png" alt="我是图片"></p><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><ol start="3"><li>topic</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5015984-275ea009bdf806a0.png" alt="我是图片"></p><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配不多不少一个单词。</p><blockquote><ul><li>basicPublish​(String exchange, String routingKey, boolean mandatory, boolean immediate, AMQP.BasicProperties props, byte[] body)</li><li>basicPublish​(String exchange, String routingKey, boolean mandatory, AMQP.BasicProperties props, byte[] body)</li><li>basicPublish​(String exchange, String routingKey, AMQP.BasicProperties props, byte[] body)</li><li>可以根据 mandatory 进行无法路由的消息进行处理</li><li>mandatory = false 无法路由的消息直接丢弃</li><li>mandatory = true 无法路由的消息通过 Return 回调函数 通知</li><li>immediate RabbitMQ 3.0 不再支持此标记</li></ul></blockquote><hr><div id="link6"></div><h2 id="RabbitMQ消息事务"><a href="#RabbitMQ消息事务" class="headerlink" title="RabbitMQ消息事务"></a>RabbitMQ消息事务</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>消息事物保证消息一定到达RabbitMQ服务器</p><p>只有三个Api</p><p>channel.txSelect() 声明启动事务模式；</p><p>channel.txComment() 提交事务；</p><p>channel.txRollback() 回滚事务；</p><p>虽然当你调用publish 发送到服务器的时候，服务器收到并不会把他立刻放到队列，只有事务提交才会进入队列</p><p>事务性能很低，事务api 比较简单没有什么好描述的了</p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>扩展知识<br>我们知道，消费者可以使用消息自动或手动发送来确认消费消息，那如果我们在消费者模式中使用事务（当然如果使用了手动确认消息，完全用不到事务的），会发生什么呢？</p><p>消费者模式使用事务</p><p>假设消费者模式中使用了事务，并且在消息确认之后进行了事务回滚，那么RabbitMQ会产生什么样的变化？</p><p>结果分为两种情况：</p><ol><li><p>autoAck=false手动应对的时候是支持事务的，也就是说即使你已经手动确认了消息已经收到了，但在确认消息会等事务的返回解决之后，在做决定是确认消息还是重新放回队列，如果你手动确认现在之后，又回滚了事务，那么已事务回滚为主，此条消息会重新放回队列；</p></li><li><p>autoAck=true如果自定确认为true的情况是不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了；</p></li></ol><hr><div id="link7"></div><h2 id="RabbitMQ消息确认"><a href="#RabbitMQ消息确认" class="headerlink" title="RabbitMQ消息确认"></a>RabbitMQ消息确认</h2><p>Confirm发送方确认模式使用和事务类似，也是通过设置Channel进行发送方确认的。</p><p>效率比事务要快</p><p>Confirm的三种实现方式：</p><ol><li><p>channel.waitForConfirms()普通发送方确认模式；</p></li><li><p>channel.waitForConfirmsOrDie()批量确认模式；</p></li><li><p>channel.addConfirmListener()异步监听发送方确认模式；</p></li></ol><p>使用 channel.confirmSelect() 开启消息确认回调</p><h3 id="普通Confirm模式"><a href="#普通Confirm模式" class="headerlink" title="普通Confirm模式"></a>普通Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test77</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    <span class="keyword">if</span>(channel.waitForConfirms())</span><br><span class="line">        System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"发送失败"</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量Confirm模式"><a href="#批量Confirm模式" class="headerlink" title="批量Confirm模式"></a>批量Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test777</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.waitForConfirmsOrDie();</span><br><span class="line">    System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">  </span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步Confirm模式"><a href="#异步Confirm模式" class="headerlink" title="异步Confirm模式"></a>异步Confirm模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">  </span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以看出，代码是异步执行的，消息确认有可能是批量确认的，是否批量确认在于返回的multiple的参数，</span></span><br><span class="line"><span class="comment">        此参数为bool值，如果true表示批量执行了deliveryTag这个值以前的所有消息，如果为false的话表示单条确认。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    channel.addConfirmListener((l, b) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"已经确认 "</span>+ l + <span class="string">" "</span> + b);</span><br><span class="line">    &#125;,(l, b) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"未确认 "</span> + l + <span class="string">" "</span> + b);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">    channel.basicPublish(<span class="string">"direct-forever"</span>,<span class="string">"Aqua-1"</span>,<span class="keyword">null</span>,getMessage().getBytes());</span><br><span class="line">  </span><br><span class="line">    System.in.read();</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>性能比较 普通模式 &lt; 批量模式 &lt; 异步模式</li></ul></blockquote><hr><div id="link8"></div><h2 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h2><p>文件需要自己创建</p><p>rabbitmq.conf和rabbitmq-env.conf的位置<br>这些文件的位置是特定于分发的。默认情况下，它们不是创建的，但希望位于每个平台的以下位置：</p><p>通用UNIX：<code>$RABBITMQ_HOME/etc/rabbitmq/</code><br>Debian：<code>/etc/rabbitmq/</code><br>RPM：<code>/etc/rabbitmq/</code><br>Mac OS（Homebrew）：<code>${install_prefix}/etc/rabbitmq/</code>，Homebrew地窖前缀通常是<code>/usr/local</code><br>Windows：<code>％APPDATA％\RabbitMQ\</code><br>如果rabbitmq-env.conf不存在，则可以在由RABBITMQ_CONF_ENV_FILE变量指定的位置手动创建。在Windows系统上，它名为rabbitmq-env.bat。</p><p>如果rabbitmq.conf不存在，可以手动创建。如果更改位置，请设置RABBITMQ_CONFIG_FILE环境变量。RabbitMQ自动将.conf扩展名附加到此变量的值。</p><p>更改后重新启动服务器。添加或删除配置文件后，Windows服务用户需要重新安装该服务</p><p><a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">官方文档</a></p><hr><div id="link9"></div><h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><h3 id="Rabbitmq集群高可用"><a href="#Rabbitmq集群高可用" class="headerlink" title="Rabbitmq集群高可用"></a>Rabbitmq集群高可用</h3><p>RabbitMQ是用erlang开发的，集群非常方便，因为erlang天生就是一门分布式语言,但其本身并不支持负载均衡。</p><p>Rabbit模式大概分为以下三种：单一模式、普通模式、镜像模式<br>集群最少需要一个磁盘节点</p><h4 id="单一模式：最简单的情况，非集群模式。"><a href="#单一模式：最简单的情况，非集群模式。" class="headerlink" title="单一模式：最简单的情况，非集群模式。"></a>单一模式：最简单的情况，非集群模式。</h4><p>没什么好说的。</p><h4 id="普通模式：默认的集群模式。"><a href="#普通模式：默认的集群模式。" class="headerlink" title="普通模式：默认的集群模式。"></a>普通模式：默认的集群模式。</h4><p>对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构。</p><p>当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。</p><p>所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连A或B，出口总在A，会产生瓶颈。</p><p>该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。</p><p>如果做了消息持久化，那么得等A节点恢复，然后才可被消费；如果没有持久化的话，然后就没有然后了……</p><h4 id="镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。"><a href="#镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。" class="headerlink" title="镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。"></a>镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。</h4><p>该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。</p><p>该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。</p><p>所以在对可靠性要求较高的场合中适用(后面会详细介绍这种模式，目前我们搭建的环境属于该模式)</p><p>启动磁盘节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>查看集群状态</p><p>rabbit1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>加入集群，只要加入其中一个节点就可以了</p><p>rabbit2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>rabbit3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>退出集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on rabbit3</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># =&gt; Stopping node rabbit@rabbit3 ...done.</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># =&gt; Resetting node rabbit@rabbit3 ...done.</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment"># =&gt; Starting node rabbit@rabbit3 ...done.</span></span><br></pre></td></tr></table></figure><p>使用Rabbit镜像功能，需要基于rabbitmq策略来实现，政策是用来控制和修改群集范围的某个vhost队列行为和Exchange行为</p><p>在cluster中任意节点启用策略，策略会自动同步到集群节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p hrsystem ha-allqueue<span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all"&#125;'</span></span><br></pre></td></tr></table></figure><p>这行命令在vhost名称为hrsystem创建了一个策略，策略名称为ha-allqueue,策略模式为 all 即复制到所有节点，包含新增节点，<br>策略正则表达式为 “^” 表示所有匹配所有队列名称。<br>例如rabbitmqctl set_policy -p hrsystem ha-allqueue “^message” ‘{“ha-mode”:”all”}’<br>注意：”^message” 这个规则要根据自己修改，这个是指同步”message”开头的队列名称，我们配置时使用的应用于所有队列，所以表达式为”^”<br>官方set_policy说明参见</p><p><a href="https://www.rabbitmq.com/rabbitmqctl.8.html#Policy_Management" target="_blank" rel="noopener">官方set_policy</a></p><p><a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">集群指南</a></p><hr><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><hr><div id="link10"></div><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p><a href="https://www.rabbitmq.com" target="_blank" rel="noopener">官网</a></p><p><a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html" target="_blank" rel="noopener">Java RabbitMQ Client Api 文档</a></p><p><a href="https://www.rabbitmq.com/api-guide.html" target="_blank" rel="noopener">RabbitMQ Java Api官方教程生肉</a></p><p><a href="https://blog.csdn.net/csdnzouqi/article/details/78926603#%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AFpublishing-messages" target="_blank" rel="noopener">RabbitMQ Java Api官方教程熟肉</a></p><p><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a></p><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p><p><a href="https://www.cnblogs.com/wyt007/p/9081931.html" target="_blank" rel="noopener">RabbitMQ集群</a></p><p><a href="http://www.cnblogs.com/flat_peach/archive/2013/04/07/3004008.html" target="_blank" rel="noopener">Rabbitmq集群高可用测试</a></p><p><a href="https://www.rabbitmq.com/rabbitmqctl.8.html" target="_blank" rel="noopener">Rabbitmqctl 文档</a></p><p><a href="https://blog.csdn.net/u011665991/article/details/89487510" target="_blank" rel="noopener">RabbitMQ系列文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#link1&quot;&gt;什么是MQ为什么使用MQ&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link2&quot;&gt;为什么选择RabbitMQ&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link3&quot;&gt;怎么安装RabbitMQ&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link4&quot;&gt;RabbitMQ怎么使用&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link5&quot;&gt;RabbitMQ概念&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link6&quot;&gt;RabbitMQ消息事物&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link7&quot;&gt;RabbitMQ消息确认&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link8&quot;&gt;RabbitMQ配置&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link9&quot;&gt;RabbitMQ集群&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#link10&quot;&gt;帮助&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 id=&quot;当前版本&quot;&gt;&lt;a href=&quot;#当前版本&quot; class=&quot;headerlink&quot; title=&quot;当前版本&quot;&gt;&lt;/a&gt;当前版本&lt;/h1&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;CentOS 7&lt;/li&gt;&lt;li&gt;Erlang 21.x&lt;/li&gt;&lt;li&gt;RabbitMQ 3.7.14&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://aphage.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://aphage.me/tags/JAVA/"/>
    
      <category term="RabbitMQ" scheme="https://aphage.me/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>csdn 突破正版链接直接下载</title>
    <link href="https://aphage.me/csdn-breakthrough-download/"/>
    <id>https://aphage.me/csdn-breakthrough-download/</id>
    <published>2018-10-10T22:53:25.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://download.csdn.net/download/anonymous1991/10137472</span></span><br><span class="line"><span class="comment">//fileId=10137472</span></span><br><span class="line"><span class="comment">//不能免积分，版权限制不能下载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csdnFileDownload</span>(<span class="params">fileId</span>)</span>&#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: <span class="string">'get'</span>,</span><br><span class="line">url: <span class="string">"/index.php/source/before_do_download/"</span>+fileId,</span><br><span class="line"><span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">jsonpcallback: <span class="string">'jsonpcallback'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">resobj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> targetUrl=resobj.actionUrl+<span class="string">"/"</span>+<span class="built_in">encodeURIComponent</span>(<span class="built_in">encodeURIComponent</span>(SMSdk.getDeviceId()));</span><br><span class="line"><span class="built_in">console</span>.log(targetUrl);</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: <span class="string">'get'</span>,</span><br><span class="line">url: targetUrl,</span><br><span class="line"><span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">jsonpcallback: <span class="string">'jsonpcallback'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">resobj</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(resobj);</span><br><span class="line">location.href=resobj.msg;</span><br><span class="line">&#125;,</span><br><span class="line">error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://aphage.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://aphage.me/tags/JavaScript/"/>
    
      <category term="csdn" scheme="https://aphage.me/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://aphage.me/hello-world/"/>
    <id>https://aphage.me/hello-world/</id>
    <published>2017-11-20T11:30:46.000Z</published>
    <updated>2020-02-27T21:22:14.705Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="事件簿" scheme="https://aphage.me/categories/%E4%BA%8B%E4%BB%B6%E7%B0%BF/"/>
    
    
  </entry>
  
</feed>
